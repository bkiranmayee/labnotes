# Cattle genome assembly and validation
---
*10/26/2016*

## Table of Contents
* [Sequence alignment and summary statistics](#stats)
* [Polished assembly](#polish)
* [Recombination map alignment and problem region identification](#recomb)
* [Assembly Correction](#corr)
	* [v1.0.3](#three)
	* [v1.0.4](#four)
	* [v1.0.5](#five)
	* [v1.0.6](#six)
	* [v1.0.7](#seven)
	* [v1.0.8](#eight)
	* [v1.0.9](#nine)
	* [v1.0.13](#thirteen)
* [Polishing the assembly](#polish)
* [SNP remapping and stats](#snps)
* [Large scale assembly error correction](#error_correction)
	* [Recmap revision](#recmap_rev)
	* [Nucmer coord strategy](#nuccoord)
* [The first sign of problems](#problems)
* [One last gasp: an automated way of correcting misassemblies](#lastgasp)
	* [v1.0.15](#fifteen)
	* [v1.0.16](#sixteen)
	* [v1.0.17](#seventeen)
	* [v1.0.18](#eighteen)
	* [Unmapped marker tests](#unmapped)
	* [v1.0.19](#nineteen)
	* [v1.0.22](#twentytwo)
	* [v1.0.23](#twentythree)
	* [Final parity checks](#finalparity)

<a name="stats"></a>
## Sequence alignment and summary statistics

I need to align the data to the following cattle assemblies: 

* The UMD3 assembly
* The Btau4 assembly
* The PacBio contigs (the march Cattle assembly)
* The finished assembly (to be generated by Aleksey)

Let's start aligning to the assemblies I have right now. I'm also going to generate the spreadsheet with the information.

> Blade14: /mnt/nfs/nfs2/dbickhart/dominette_asm

```bash
ls /mnt/nfs/nfs2/SequenceData/Dominette/Dominette_NextSeq_data/*/*.fastq.gz | perl -MFile::Basename -e '%data; while(<>){chomp; $orig = $_; $bname = basename($_); @entries = split(/\//, $orig); @bentries = split(/_/, $bname); $data{"$entries[-2]_$bentries[2]"}->{$bentries[3]} = $orig;} foreach my $k (keys(%data)){print $data{$k}->{"R1"} . "\t" . $data{$k}->{"R2"} . "\tdominette\tdominette\n";}' > dominette_nextseq_file_list.tab

# UMD3
perl ~/perl_toolchain/sequence_data_pipeline/runMergedBamPipeline.pl --fastqs dominette_nextseq_file_list.tab --output umd3 --reference ../../Genomes/Bos_taurus.UMD3.1.73.fa --config ./quick_pipeline.cnfg --threads 4

```

Serge's pipeline only works with SGE. I need to hijack some of his commands to run Lumpy and the other tools without using his full pipeline.

```bash
# Preparing discordant and split read bam files
samtools view -b -F 1294 btau4/dominette_merged_btau4.bam > btau4/dominette_merged_btau4.discordants.bam
samtools view -h btau4/dominette_merged_btau4.bam \
          | ~/lumpy-sv/scripts/extractSplitReads_BwaMem -i stdin \
          | samtools view -Sb - \
          > btau4/dominette_merged_btau4.splitters.bam

samtools index btau4/dominette_merged_btau4.discordants.bam
samtools index btau4/dominette_merged_btau4.splitters.bam

# Lumpy analysis
pars=`samtools view btau4/dominette_merged_btau4.bam | head -n100000 | ~/lumpy-sv/scripts/pairend_distro.py -r 150 -X 4 -N 10000 -o btau4/dominette_merged_btau4.histo`
mean=`echo $pars | grep 'mean' | awk '{print $1}' |sed s/mean://g`
sd=`echo $pars |grep 'mean' | awk '{print $NF}' |sed s/stdev://g`
MIN=`echo "$mean $sd" |awk '{printf("%d\n", $1-3*$2)}' |awk '{if ($1 < 0) print 0}'`
MAX=`echo "$mean $sd" |awk '{printf("%d\n", $1+3*$2)}'`

PE=""
SR=""

PE="$PE -pe id:sample,bam_file:btau4/dominette_merged_btau4.discordants.bam,histo_file:btau4/dominette_merged_btau4.histo,mean:$mean,stdev:$sd,read_length:150,min_non_overlap:150,discordant_z:5,back_distance:10,weight:1,min_mapping_threshold:20"
SR="$SR -sr id:sample,bam_file:btau4/dominette_merged_btau4.splitters.bam,back_distance:10,min_mapping_threshold:20,weight:1,min_clip:20"
lumpy -mw 4 -tt 0 $PE $SR > btau4/dominette_merged_btau4.lumpy.vcf

# FRC bam
PE=""
PE="$PE --pe-sam btau4/dominette_merged_btau4.bam --pe-max-insert $MAX"
FRC $PE --genome-size $GS --output btau4/dominette_merged_btau4

# Freebayes
$FREEBAYES -C 2 -0 -O -q 20 -z 0.02 -E 0 -X -u -p 1 -F 0.5 -b btau4/dominette_merged_btau4.bam -v btau4/dominette_merged_btau4.bayes.vcf -f $ASM

# QV estimate
NUM_SNP=`cat btau4/dominette_merged_btau4.bayes.vcf |grep -v "#" | awk -F "\t" '{print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$8}' | tr ';' ' ' | sed s/AB=//g | awk -v WEIGHT=$WEIGHT '{if ($6 > WEIGHT) print $0}' | awk -v SUM=0 '{if (length($4) == length($5)) { SUM+=length($4); } else if (length($4) < length($5)) { SUM+=length($5)-length($4); } else { SUM+=length($4)-length($5)}} END { print SUM}'`

NUM_BP=`samtools depth btau4/dominette_merged_btau4.bam |awk '{if ($NF >= 3) SUM++; } END { print SUM}'`
QV=`echo "$NUM_SNP $NUM_BP" | awk '{print (-10*log($1/$2)/log(10))}'`
echo $QV > btau4/dominette_merged_btau4.qv
```

I consolidated the above code into a shell script that can run on each merged bam file in sequence.

```bash
sh serge_script_oneshot.sh btau4/dominette_merged_btau4 /mnt/iscsi/vnx_gliu_7/reference/bosTau4.fa.gz

sh serge_script_oneshot.sh umd3/dominette.merged.umd3 /mnt/iscsi/vnx_gliu_7/reference/umd3_kary_unmask_ngap.fa

sh serge_script_oneshot.sh canu/canu.dominette.topolish canu/topolish.filledWithCanuAndPBJelly.fasta
```

I am also queuing up the new assembly (pre pilon).

```bash
bwa index canu/topolish.filledWithCanuAndPBJelly.fasta.gz ; samtools faidx canu/topolish.filledWithCanuAndPBJelly.fasta.gz ; perl ~/perl_toolchain/sequence_data_pipeline/runMergedBamPipeline.pl --fastqs dominette_nextseq_file_list.tab --output canu --reference canu/topolish.filledWithCanuAndPBJelly.fasta.gz --config ./quick_pipeline.cnfg --threads 4
```

OK, the shell script had a few problems. For starters, freebayes can't handle gzipped fastas. Rerunning the last steps of the pipeline.

```bash
# btau4
samtools depth dominette_merged_btau4.bam | perl -e '$c = 0; while(<>){chomp; @s = split(/\t/); if($s[2] >= 3){$c++;}} print "$c\n";'
	2697640645
freebayes -C 2 -0 -O -q 20 -z 0.02 -E 0 -X -u -p 2 -F 0.5 -b dominette_merged_btau4.bam -v dominette_merged_btau4.bayes.vcf -f /mnt/iscsi/vnx_gliu_7/reference/bosTau4.fa
perl -e '$c = 0; while(<>){chomp; @F = split(/\t/); if($F[0] =~ /^#/){next;} ($ab) = $F[7] =~ /AB=(.{1,10})\;ABP/; if($ab < 0.65){next;}else{ $la = length($F[3]); $lb = length($F[4]); if($la == $lb){$c++;}elsif($la < $lb){$c += $lb - $la;}else{$c += $la - $lb;}}} print "$c\n";' < dominette_merged_btau4.bayes.vcf
	281999

perl -e '$ns = 281999; $nb = 2697640645; print (-10 * log($ns/$nb)/log(10)); print "\n";'
	39.8073652818702 # Btau4 qv

perl ~/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f dominette_merged_btau4_Features.txt -c 1
Entry   Count
COMPR_PE        6407
HIGH_COV_PE     4406
HIGH_NORM_COV_PE        3671
HIGH_OUTIE_PE   988
HIGH_SINGLE_PE  3247
HIGH_SPAN_PE    9240
LOW_COV_PE      135529
LOW_NORM_COV_PE 137377
STRECH_PE       16385

perl -lane '$F[10] =~ s/TYPE://g; print "$F[10]";' < dominette_merged_btau4.lumpy.vcf | perl ~/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 0
Entry   Count
DELETION        12870
DUPLICATION     1305
INTERCHROM      9031
INVERSION       2152

# Errors per 100 mbp = (25358 / 28.0) = 905.64

# umd3
samtools depth dominette.merged.umd3.bam | perl -e '$c = 0; while(<>){chomp; @s = split(/\t/); if($s[2] >= 3){$c++;}} print "$c\n";'
	2633997017
freebayes -C 2 -0 -O -q 20 -z 0.02 -E 0 -X -u -p 2 -F 0.5 -b dominette.merged.umd3.bam -v dominette.merged.umd3.bayes.vcf -f ../../../Genomes/Bos_taurus.UMD3.1.73.fa
perl -e '$c = 0; while(<>){chomp; @F = split(/\t/); if($F[0] =~ /^#/){next;} ($ab) = $F[7] =~ /AB=(.{1,10})\;ABP/; if($ab < 0.65){next;}else{ $la = length($F[3]); $lb = length($F[4]); if($la == $lb){$c++;}elsif($la < $lb){$c += $lb - $la;}else{$c += $la - $lb;}}} print "$c\n";' < dominette.merged.umd3.bayes.vcf
	300091

perl -e '$ns = 300091; $nb = 2633997017; print (-10 * log($ns/$nb)/log(10)); print "\n";'
	39.4336230805122 # UMD3 qv

perl ~/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f dominette.merged.umd3_Features.txt -c 1
Entry   Count
COMPR_PE        12348
HIGH_COV_PE     7660
HIGH_NORM_COV_PE        7169
HIGH_OUTIE_PE   2303
HIGH_SINGLE_PE  1295
HIGH_SPAN_PE    4135
LOW_COV_PE      64527
LOW_NORM_COV_PE 67417
STRECH_PE       21891

perl -lane '$F[10] =~ s/TYPE://g; print "$F[10]";' < dominette.merged.umd3.lumpy.vcf | perl ~/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 0
Entry   Count
DELETION        13963
DUPLICATION     2493
INTERCHROM      8711
INVERSION       5470

# Errors per 100 mbp = (30637 / 28.0) = 1094.18


## Computomix
perl ~/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f canu/canu.dominette.topolish_Features.txt -c 1
Entry   Count
COMPR_PE        6526
HIGH_COV_PE     7333
HIGH_NORM_COV_PE        5759
HIGH_OUTIE_PE   80
HIGH_SINGLE_PE  118
HIGH_SPAN_PE    5982
LOW_COV_PE      52772
LOW_NORM_COV_PE 50719
STRECH_PE       16752

lumpy -mw 4 -tt 0 -pe id:sample,bam_file:canu.dominette.topolish.discordants.bam,histo_file:canu.dominette.topolish.histo,mean:628.478,stdev:168.47,read_length:150,min_non_overlap:150,discordant_z:5,back_distance:10,weight:1,min_mapping_threshold:20 -sr id:sample,bam_file:canu.dominette.topolish.splitters.bam,back_distance:10,min_mapping_threshold:20,weight:1,min_clip:20 > canu.dominette.topolish.lumpy.vcf

perl -lane '$F[10] =~ s/TYPE://g; print "$F[10]";' < canu/canu.dominette.topolish.lumpy.vcf  | perl ~/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 0
Entry   Count
DELETION        4272
DUPLICATION     320
INTERCHROM      2132
INVERSION       487


```

OK, let's summarize things:

| Feature | Btau4 | UMD3 | Serge | Aleksey |Description |
| :--- | ---: | ---: | ---: | ---: |:--- |
| QV | 39.80 | 39.43 | 32.78 | 38.85 | Phred-based assessment of INDEL and SNP errors in assembly |
| Errors / 100 Mbp | 905.64 | 1094.18 | 257 | 213.75 | Ratio of Lumpy SV calls per 100 Mbp |
| DELETION | 12870 | 13963 | 4272 | 1363 | Lumpy-SV deletions |
| DUPLICATION | 1305 | 2493 | 320 | 611 | Lumpy-SV duplications |
| INTERCHROM | 9031 |  8711 | 2132| 3943 | Lumpy-SV interchromosome regions |
| INVERSION | 2152 |  5470 | 487 | 68 | Lumpy-SV inversions |
|COMPR_PE         |   6407|12348| 6526| 9000 | Areas with low CE statistics |
|HIGH_COV_PE      |   4406|7660| 7333| 10098 | Higher read coverage |
|HIGH_NORM_COV_PE |   3671|7169| 5759 | 7944 | High coverage of normal paired-end reads |
|HIGH_OUTIE_PE    |    988|2303| 80| 79 | Regions with high numbers of misoriented or distant pairs |
|HIGH_SINGLE_PE   |   3247|1295| 118 | 251 |Regions with high numbers of unmapped pairs |
|HIGH_SPAN_PE     |   9240|4135| 5982 | 14180 |Regions with high numbers of disc. pairs that map to different scaffolds |
|LOW_COV_PE       | 135529|64527| 52772 | 100814 |Low read coverage |
|LOW_NORM_COV_PE  | 137377|67417| 50719 | 105271 |Low coverage of normal paired-end reads |
|STRECH_PE        |  16385|21891| 16752 | 15079 |Areas with high CE statistics |

<a name="polished"></a>
## Polished assembly

Now that we have the polished assembly back from Aleksey, it's time to process it.

```bash
module load bwa
module load samtools/1.3-20-gd49c73b

sbatch --mem=20000 --nodes=1 --ntasks-per-node=5 --wrap="bwa index polished.fa"
sbatch --mem=2000 --nodes=1 --ntasks-per-node=1 --wrap="samtools faidx polished.fa"

sbatch --mem=20000 --nodes=1 --ntasks-per-node=5 --wrap="java -Xmx19g -jar /mnt/nfs/nfs2/bickhart-users/binaries/GetMaskBedFasta/store/GetMaskBedFasta.jar -f polished.fa -o polished.gaps.bed -s polished.gaps.stats"
sbatch --nodes=1 --mem=2000 --ntasks-per-node=8 --wrap 'samtools merge -c -p --threads 8 polished.merged.dominette.bam polishedAsm.NextSeq.dominette.dominette.LIB18483_S1_L001_001.bam polishedAsm.NextSeq.dominette.dominette.LIB18483_S1_L002_001.bam polishedAsm.NextSeq.dominette.dominette.LIB18483_S1_L003_001.bam polishedAsm.NextSeq.dominette.dominette.LIB18483_S1_L004_001.bam'

sbatch --nodes=1 --ntasks-per-node=1 --mem=1000 --wrap='samtools index bwa-out/polished.merged.dominette.bam'
sbatch serge_script_oneshot.sh polished/bwa-out/polished.merged.dominette polished/polished.fa

# Lumpy failed because of weird scripting errors. Rerunning...
sbatch --mem=20000 --nodes=1 --ntasks-per-node=5 --wrap="module load lumpy-sv/0.2.12-51-g16b6876; samtools view polished.merged.dominette.bam | tail -n+100000 | /opt/agil_cluster/lumpy-sv-0.2.12-51-g16b6876/bin/../scripts/pairend_distro.py -r 150 -X 4 -N 10000 -o polished.merged.dominette.histo"

sbatch --mem=20000 --nodes=1 --ntasks-per-node=5 --wrap="module load lumpy-sv/0.2.12-51-g16b6876; lumpy -mw 4 -tt 0 -pe id:dominette,bam_file:polished.merged.dominette.bam,histo_file:polished.merged.dominette.histo,mean:626.926292629,stdev:193.453829908,read_length:150,min_non_overlap:150,discordant_z:5,back_distance:10,weight:1,min_mapping_threshold:20 > polished.merged.dominette.lumpy.vcf"

./vcfToBedpe -i polished/bwa-out/polished.merged.dominette.lumpy.vcf -o polished/bwa-out/polished.merged.dominette.lumpy.bedpe

perl -e '$c = 0; while(<>){chomp; @F = split(/\t/); if($F[0] =~ /^#/){next;} ($ab) = $F[7] =~ /AB=(.{1,10})\;ABP/; if($ab < 0.65){next;}else{ $la = length($F[3]); $lb = length($F[4]); if($la == $lb){$c++;}elsif($la < $lb){$c += $lb - $la;}else{$c += $la - $lb;}}} print "$c\n";' < polished.merged.dominette.bayes.vcf
353921
samtools depth polished.merged.dominette.bam | perl -e '$c = 0; while(<>){chomp; @s = split(/\t/); if($s[2] >= 3){$c++;}} print "$c\n";'
2720125193
perl -e 'chomp(@ARGV); $ns = $ARGV[0]; $nb = $ARGV[1]; print (-10 * log($ns/$nb)/log(10)); print "\n";' 353921 2720125193
38.8568256039133

# Checking to see if the SNPs and indels correspond to lumpy SV calls
# Pulling lumpy calls into beds and then pulling only the >65% AB percentile variants from the freebayes output
perl -lane 'if($F[0] =~ /^#/){next;} if($F[1] < 0){ $F[1] = 0;} if($F[3] < 0){$F[3] = 0;} if($F[10] eq "BND"){print "$F[0]\t$F[1]\t$F[2]\t$F[10]"; print "$F[3]\t$F[4]\t$F[5]\t$F[10]";}else{print "$F[0]\t$F[1]\t$F[5]\t$F[10]";}' < polished.merged.dominette.lumpy.bedpe > polished.merged.dominette.lumpy.bed
perl -lane 'if($F[0] =~ /^#/){next;} ($ab) = $F[7] =~ /AB=(.{1,10})\;ABP/; if($ab < 0.65){next;} $e = $F[1] + 1; print "$F[0]\t$F[1]\t$e";' < polished.merged.dominette.bayes.vcf > polished.merged.dominette.bayes.bed
intersectBed -a polished.merged.dominette.lumpy.bed -b polished.merged.dominette.bayes.bed -c | perl -lane 'if($F[4] > 0){print $_;}' | wc -l
2417   <- total SNPs/INDELs within lumpy predicted discordant regions (~24% of total)
perl -lane 'if($F[0] =~ /^#/){next;} ($ab) = $F[7] =~ /AB=(.{1,10})\;ABP/; if($ab < 0.65){next;} $e = $F[1] + 1; print "$F[0]\t$F[1]\t$e";' < polished.merged.dominette.bayes.vcf > polished.merged.dominette.bayes.bed
[dbickhart@vm-agil-251-fry bwa-out]$ intersectBed -a polished.merged.dominette.lumpy.bed -b polished.merged.dominette.bayes.bed -c | perl -lane 'if($F[4] > 0){print $_;}' | perl ~/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 3 -m
```
### Variants within lumpy sv coordinates in polished assembly
|Entry | Count|
|:-----|-----:|
|BND   |  1436|
|DEL   |   506|
|DUP   |   432|
|INV   |    43|


<a name="ctx"></a>
## Computomix assembly

The polished assembly looks corrupted... I'm going to run a comparison with the real computomix assembly to see how that panned out.

> fry: /mnt/nfs/nfs2/dbickhart/dominette_asm/ctx

```bash
sh create_bwa_batchfiles.sh dominette_nextseq_file_list.tab
sbatch --nodes=1 --ntasks-per-node=2 --mem=10000 --wrap="module load bwa; module load samtools; bwa index CTX3.fasta; samtools faidx CTX3.fasta"

sleep 3h; find batchfiles-bwa/ -name *.sh | xargs -I {} sbatch {}
sbatch --nodes=1 --ntasks-per-node=10 --mem=5000 --wrap="module load samtools/1.3-20-gd49c73b; samtools merge -c -p -@ 9 polishedAsm.NextSeq.dominette.merged.bam polishedAsm.NextSeq.dominette.dominette.LIB18483_S1_L001_001.bam polishedAsm.NextSeq.dominette.dominette.LIB18483_S1_L002_001.bam polishedAsm.NextSeq.dominette.dominette.LIB18483_S1_L003_001.bam polishedAsm.NextSeq.dominette.dominette.LIB18483_S1_L004_001.bam; samtools index polishedAsm.NextSeq.dominette.merged.bam;"

sbatch ../serge_script_oneshot.sh bwa-out/polishedAsm.NextSeq.dominette.merged CTX3.fasta dominette
```

## Other assemblies

Aleksey made two additional assemblies that need to be run through the pipeline.

> fry: /mnt/nfs/nfs2/dbickhart/dominette_asm/

```bash
#### Polished.final ####
mkdir polished.final
cd polished.final

sbatch --nodes=1 --mem=6000 --ntasks-per-node=1 --wrap="module load bwa; module load samtools; wget ftp://ftp.genome.umd.edu/pub/dominette/polished.final.fa.gz; gunzip polished.final.fa.gz; bwa index polished.final.fa; samtools faidx polished.final.fa;"

perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b alignments -t ../dominette_nextseq_file_list.tab -f polished.final.fa -m
sbatch serge_script_oneshot.sh polished.final/alignments/dominette/dominette.sorted.merged polished.final/polished.final.fa dominette

#### Topolish no 1b ####
mkdir topolish.no1b
cd topolish.no1b

sbatch --nodes=1 --mem=6000 --ntasks-per-node=1 --wrap="module load bwa; module load samtools; wget ftp://ftp.genome.umd.edu/pub/dominette/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta.gz; gunzip topolish.filledWithCanuAndPBJelly.withX.no1b.fasta.gz; bwa index topolish.filledWithCanuAndPBJelly.withX.no1b.fasta; samtools faidx topolish.filledWithCanuAndPBJelly.withX.no1b.fasta;"

perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b alignments -t ../dominette_nextseq_file_list.tab -f topolish.filledWithCanuAndPBJelly.withX.no1b.fasta -m
sbatch serge_script_oneshot.sh topolish.no1b/alignments/dominette/dominette.sorted.merged topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta dominette

# Damn, I suspect that Slurm automatically kills jobs that post with an ampersand. Going to queue up FRC and lumpy using separate commands
sbatch --nodes=1 --ntasks-per-node=2 --mem=25000 --wrap="module load lumpy-sv/0.2.12-51-g16b6876; lumpy -mw 4 -tt 0  -pe id:dominette,bam_file:topolish.no1b/alignments/dominette/dominette.sorted.merged.discordants.bam,histo_file:topolish.no1b/alignments/dominette/dominette.sorted.merged.histo,mean:626.861177885,stdev:184.997331276,read_length:150,min_non_overlap:150,discordant_z:5,back_distance:10,weight:1,min_mapping_threshold:20 > topolish.no1b/alignments/dominette/dominette.sorted.merged.lumpy.2.vcf"
sbatch --nodes=1 --ntasks-per-node=2 --mem=25000 --wrap="module load FRC_align/1.3.0-5b3f53e; FRC  --pe-sam topolish.no1b/alignments/dominette/dominette.sorted.merged.bam --pe-max-insert 1181 --genome-size 2800000000 --output topolish.no1b/alignments/dominette/dominette.sorted.merged.2"

sbatch --nodes=1 --ntasks-per-node=2 --mem=25000 --wrap="module load lumpy-sv/0.2.12-51-g16b6876; lumpy -mw 4 -tt 0  -pe id:dominette,bam_file:polished.final/alignments/dominette/dominette.sorted.merged.discordants.bam,histo_file:polished.final/alignments/dominette/dominette.sorted.merged.histo,mean:666.1878,stdev:182.802370146,read_length:150,min_non_overlap:150,discordant_z:5,back_distance:10,weight:1,min_mapping_threshold:20 > polished.final/alignments/dominette/dominette.sorted.merged.lumpy.2.vcf"
```

#### Update of stats table

| Feature | Btau4 | UMD3 | Serge | Aleksey | polished.final | topolish.no1b |Description |
| :--- | ---: | ---: | ---: | ---: | ---: | ---: |:--- |
| QV | 39.80 | 39.43 | 32.78 | 38.85 | 38.23 | 40.87 |Phred-based assessment of INDEL and SNP errors in assembly |
| Errors / 100 Mbp | 905.64 | 1094.18 | 257 | 213.75 | | | Ratio of Lumpy SV calls per 100 Mbp |
| DELETION | 12870 | 13963 | 4272 | 1363 | | | Lumpy-SV deletions |
| DUPLICATION | 1305 | 2493 | 320 | 611 | | | Lumpy-SV duplications |
| INTERCHROM | 9031 |  8711 | 2132| 3943 | | | Lumpy-SV interchromosome regions |
| INVERSION | 2152 |  5470 | 487 | 68 | | | Lumpy-SV inversions |
|COMPR_PE         |   6407|12348| 6526| 9000 | 68847 | 174622 | Areas with low CE statistics |
|HIGH_COV_PE      |   4406|7660| 7333| 10098 | 10320 | 7214 | Higher read coverage |
|HIGH_NORM_COV_PE |   3671|7169| 5759 | 7944 | 8185 | 5481 | High coverage of normal paired-end reads |
|HIGH_OUTIE_PE    |    988|2303| 80| 79 | 133 | 122 | Regions with high numbers of misoriented or distant pairs |
|HIGH_SINGLE_PE   |   3247|1295| 118 | 251 | 306 | 92 | Regions with high numbers of unmapped pairs |
|HIGH_SPAN_PE     |   9240|4135| 5982 | 14180 | 14993 | 5166 | Regions with high numbers of disc. pairs that map to different scaffolds |
|LOW_COV_PE       | 135529|64527| 52772 | 100814 | 107927 | 58672 | Low read coverage |
|LOW_NORM_COV_PE  | 137377|67417| 50719 | 105271 | 111927 | 57701 | Low coverage of normal paired-end reads |
|STRECH_PE        |  16385|21891| 16752 | 15079 | 39885 | 94925 | Areas with high CE statistics |


Now to generate a FRC curve to compare stats.

```R
data.serge <- read.delim("canu/canu.dominette.topolish_FRC.txt", sep=" ", header=FALSE)
data.aleksey <- read.delim("polished/bwa-out/polished.merged.dominette_FRC.txt", sep=" ", header=FALSE)
data.topolish <- read.delim("topolish.no1b/alignments/dominette/dominette.sorted.merged_FRC.txt", sep=" ", header=FALSE)
data.final <- read.delim("polished.final/alignments/dominette/dominette.sorted.merged_FRC.txt", sep=" ", header=FALSE)
pdf(file="frc_curve_fourasms.pdf", useDingbats=FALSE)

plot(data.serge$V1, data.serge$V2, type="l", col="red")
lines(data.aleksey$V1, data.aleksey$V2, col="green")
lines(data.topolish$V1, data.topolish$V2, col="blue")
lines(data.final$V1, data.final$V2, col="brown")
legend("topleft", legend = c("Serge", "Aleksey1", "Aleksey2", "topolishNob1"), col = c("red", "green", "blue", "brown"))
dev.off()

pdf(file="frc_curve_threeasms.pdf", useDingbats=FALSE)
plot(data.aleksey$V1, data.aleksey$V2, col="green", type="l")
lines(data.topolish$V1, data.topolish$V2, col="blue")
lines(data.final$V1, data.final$V2, col="brown")
legend("topleft", legend = c("Aleksey1", "Aleksey2", "topolishNoB1"), lty=c(1,1), lwd=c(2,2), col = c("green", "blue", "brown"))

```

Rerunning only on run2 data

```bash
mkdir run2only
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b umd3 -t ../dominett_run2_only_files.tab -f /mnt/nfs/nfs2/Genomes/umd3_kary_unmask_ngap.fa -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b canu -t ../dominett_run2_only_files.tab -f ../canu/topolish.filledWithCanuAndPBJelly.fasta -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b ctx -t ../dominett_run2_only_files.tab -f ../ctx/CTX3.fasta -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b polished -t ../dominett_run2_only_files.tab -f ../polished/polished.fa -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b polished.final -t ../dominett_run2_only_files.tab -f ../polished.final/polished.final.fa -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b topolish.no1b -t ../dominett_run2_only_files.tab -f ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta -m

sbatch serge_script_oneshot.sh run2only/canu/dominette/dominette.sorted.merged canu/topolish.filledWithCanuAndPBJelly.fasta dominette
sbatch serge_script_oneshot.sh run2only/ctx/dominette/dominette.sorted.merged ctx/CTX3.fasta dominette
sbatch serge_script_oneshot.sh run2only/umd3/dominette/dominette.sorted.merged /mnt/nfs/nfs2/Genomes/umd3_kary_unmask_ngap.fa dominette
sbatch serge_script_oneshot.sh run2only/polished/dominette/dominette.sorted.merged polished/polished.fa dominette
sbatch serge_script_oneshot.sh run2only/polished.final/dominette/dominette.sorted.merged polished.final/polished.final.fa dominette
sbatch serge_script_oneshot.sh run2only/topolish.no1b/dominette/dominette.sorted.merged topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta dominette
```

Rerunning only on run1 data

```bash
mkdir run1only
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b umd3 -t ../dominette_run1_only_nextseq_file_list.tab -f /mnt/nfs/nfs2/Genomes/umd3_kary_unmask_ngap.fa -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b canu -t ../dominette_run1_only_nextseq_file_list.tab -f ../canu/topolish.filledWithCanuAndPBJelly.fasta -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b ctx -t ../dominette_run1_only_nextseq_file_list.tab -f ../ctx/CTX3.fasta -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b polished -t ../dominette_run1_only_nextseq_file_list.tab -f ../polished/polished.fa -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b polished.final -t ../dominette_run1_only_nextseq_file_list.tab -f ../polished.final/polished.final.fa -m
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b topolish.no1b -t ../dominette_run1_only_nextseq_file_list.tab -f ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta -m

# Running all of the diagnostic scripts as dependent jobs
sbatch --dependency=afterok:656252 serge_script_oneshot.sh /mnt/nfs/nfs2/dbickhart/dominette_asm/run1only/topolish.no1b/dominette/dominette.sorted.merged topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta dominette
sbatch --dependency=afterok:656247 serge_script_oneshot.sh /mnt/nfs/nfs2/dbickhart/dominette_asm/run1only/polished.final/dominette/dominette.sorted.merged polished.final/polished.final.fa dominette
sbatch --dependency=afterok:656242 serge_script_oneshot.sh /mnt/nfs/nfs2/dbickhart/dominette_asm/run1only/polished/dominette/dominette.sorted.merged polished/polished.fa dominette
sbatch --dependency=afterok:656237 serge_script_oneshot.sh /mnt/nfs/nfs2/dbickhart/dominette_asm/run1only/ctx/dominette/dominette.sorted.merged ctx/CTX3.fasta dominette
sbatch --dependency=afterok:656232 serge_script_oneshot.sh /mnt/nfs/nfs2/dbickhart/dominette_asm/run1only/canu/dominette/dominette.sorted.merged canu/topolish.filledWithCanuAndPBJelly.fasta dominette
sbatch --dependency=afterok:656227 serge_script_oneshot.sh /mnt/nfs/nfs2/dbickhart/dominette_asm/run1only/umd3/dominette/dominette.sorted.merged /mnt/nfs/nfs2/Genomes/umd3_kary_unmask_ngap.fa dominette

for i in `ls run1only/*/dominette/dominette.sorted.merged.lumpy.vcf`; do dir=`dirname $i`; echo $dir; ./vcfToBedpe -i $i -o $dir/dominette.sorted.merged.lumpy.bedpe; done
perl ../../bickhart-users/binaries/GoatAssemblyScripts/assembly_frc_benchmarking/summarizeAnalysisSlurm.pl -b run1only/canu/dominette/dominette.sorted.merged,run1only/ctx/dominette/dominette.sorted.merged,run1only/polished/dominette/dominette.sorted.merged,run1only/polished.final/dominette/dominette.sorted.merged,run1only/topolish.no1b/dominette/dominette.sorted.merged,run1only/umd3/dominette/dominette.sorted.merged -n canu,ctx,polished,polished.final,topolish.no1b,umd3 -o slurm_summary_stats_run2only.md
```

|Entry            | canu | ctx |polished|p.final|topolish.no1b| umd3|
|:----------------|-----:|-----:|-----:|-----:|-----:|-----:|
|BND              |  3157|   842|  4077|  3298|  2681| 13258|
|INV              |    85|    83|   110|    99|    73|  2157|
|DEL              |  1593|  1348|  2159|  2013|  1491| 12069|
|DUP              |   450|   458|  1120|  1202|   439|  3222|
|HIGH_COV_PE      |  7419|  7498|  9743|  9844|  7234|  6605|
|HIGH_NORM_COV_PE |  5567|  5573|  7581|  7656|  5464|  5849|
|HIGH_OUTIE_PE    |    85|    41|    80|    95|    90|  2280|
|HIGH_SINGLE_PE   |   191|   242|   234|   253|    83|  1289|
|HIGH_SPAN_PE     |  9926|  9480| 13695| 13784|  4986|  3959|
|LOW_COV_PE       | 42779| 36226| 75878| 76200| 55912| 50934|
|LOW_NORM_COV_PE  | 41385| 34820| 82166| 82693| 55203| 55638|
|STRECH_PE        | 27257| 25495| 26656| 25697| 27470| 28936|
|COMPR_PE         | 13937| 17704| 28604| 24878| 14454| 22221|
|QV               |    41|    41|    40|    40|    41|    41|


Plotting the data in an FRC curve in R

```R
data.canu <- read.delim("run1only/canu/dominette/dominette.sorted.merged_FRC.txt", sep=" ", header=FALSE)
data.ctx <- read.delim("run1only/ctx/dominette/dominette.sorted.merged_FRC.txt", sep=" ", header=FALSE)
data.polished <- read.delim("run1only/polished/dominette/dominette.sorted.merged_FRC.txt", sep=" ", header=FALSE)
data.polished.final <- read.delim("run1only/polished.final/dominette/dominette.sorted.merged_FRC.txt", sep=" ", header=FALSE)
data.topolish.no1b <- read.delim("run1only/topolish.no1b/dominette/dominette.sorted.merged_FRC.txt", sep=" ", header=FALSE)
data.umd3 <- read.delim("run1only/umd3/dominette/dominette.sorted.merged_FRC.txt", sep=" ", header=FALSE)

pdf(file="frc_curve_run1only_data_frc.pdf", useDingbats=FALSE)

plot(data.canu$V1, data.canu$V2, type="l", col="red")
lines(data.ctx$V1, data.ctx$V2, col="blue")
lines(data.polished$V1, data.polished$V2, col="green")
lines(data.polished.final$V1, data.polished.final$V2, col="brown")
lines(data.topolish.no1b$V1, data.topolish.no1b$V2, col="purple")
lines(data.umd3$V1, data.umd3$V2, col="orange")
legend("topleft", legend = c("canu", "ctx", "polished", "polished.final", "topolish.no1b", "umd3"), lty=c(1,1), lwd=c(2,2), col=c("red", "blue", "green", "brown", "purple", "orange"))

dev.off()
```

OK our decision was to go with the topolish.no1b assembly.

<a name="recomb"></a>
## Recombination map alignment and problem region identification 

Using the recombination map information, I need to remap probes and identify breakpoints in order. Bob has data on his comparisons with the linkage map he has in his database. Both the recombination map and linkage map are highly similar, so they are all but interchangeable. I am going to remap probes and identify the major breakpoints.

First things first, let's extract the fasta sequence from the manifest file.

> Fry: /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination

```bash
perl -e 'for(my $x = 0; $x < 8; $x++){<>;} while(<>){chomp; @s = split(/,/); print ">$s[1].$s[9].$s[10]\n$s[5]\n";}' < rcmap_manifest.csv > rcmap_manifest.fa

sbatch alignAndOrderSnpProbes.pl -a ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta -p rcmap_manifest.fa -o rcmap_test_run_topolish.no1b

# Testing canu alignments on topolish:
perl alignAndOrderSnpProbes.pl -n toPolishVsCanu.long1coords -o toPolishVsCanuTest

# Identifying regions that have zero read coverage in topolish
sbatch --nodes=1 --mem=20000 --ntasks-per-node=1 --wrap="module load bedtools/2.25.0; bedtools genomecov -ibam topolish.no1b/alignments/dominette/dominette.sorted.merged.bam -g topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta -d | perl -lane 'if($F[2] == 0){print $_;}' > topolish.no1b/topolish.no1b.bases_zero_cov.tab"

perl condense_zero_cov_regions.pl topolish.no1b.cov.tab topolish.no1b.bases_zero_cov.bed

sbatch --nodes=1 --mem=10000 --ntasks-per-node=2 --wrap="module load java/jdk1.8.0_92; java -Xmx10g -jar ../../../bickhart-users/binaries/GetMaskBedFasta/store/GetMaskBedFasta.jar -f topolish.filledWithCanuAndPBJelly.withX.no1b.fasta -o topolish.filledWithCanuAndPBJelly.withX.no1b.gaps.bed -s topolish.filledWithCanuAndPBJelly.withX.no1b.gaps.stats"

# Removing zero coverage bases under 5bp (most indels
perl -lane 'if($F[2] - $F[1] > 5){print $_;}' < topolish.no1b.bases_zero_cov.bed > topolish.no1b.bases_zero_cov.gt5bp.bed
wc -l topolish.no1b.bases_zero_cov.bed topolish.no1b.bases_zero_cov.gt5bp.bed
  97988 topolish.no1b.bases_zero_cov.bed
  74211 topolish.no1b.bases_zero_cov.gt5bp.bed

intersectBed -a topolish.filledWithCanuAndPBJelly.withX.no1b.gaps.bed -b topolish.no1b.bases_zero_cov.gt5bp.bed -wa | wc -l
521 <- that's all 520 gaps + some bases on the side

intersectBed -a topolish.no1b.bases_zero_cov.gt5bp.bed -b topolish.filledWithCanuAndPBJelly.withX.no1b.gaps.bed -v > topolish.no1b.bases_zero_cov.gt5bp.nogaps.bed

wc -l topolish.no1b.bases_zero_cov.gt5bp.nogaps.bed
	73690 topolish.no1b.bases_zero_cov.gt5bp.nogaps.bed  <- thats 74211 zero cov - 521 gaps

# Dammit! The coordinates in the manifest file are for UMD3, not the rc map!
# Correcting it
perl -e 'chomp(@ARGV); my %h; open($IN, "< $ARGV[0]"); <$IN>; while(<$IN>){chomp; @s = split(/,/); $h{$s[0]} = [$s[1], $s[2]];} close $IN; open($IN, "< $ARGV[1]"); for(my $x = 0; $x < 8; $x++){<$IN>;} while(<$IN>){chomp; @s = split(/,/); if(exists($h{$s[1]})){$chr = $h{$s[1]}->[0]; $pos = $h{$s[1]}->[1]; print ">$s[1].$chr.$pos\t$s[5]\n";}else{print ">$s[1].$s[9].$s[10]\t$s[5]\n";}}' /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_hits.csv /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest.csv | perl -e '%d; while($l = <>){chomp $l; @s = split(/\t/, $l); @n = split(/\./, $s[0]); $d{$n[1]}->{$n[2]} = $l;} foreach my $chr (sort{$a <=> $b} keys(%d)){foreach my $pos (sort{$a <=> $b} keys(%{$d{$chr}})){ @h = split(/\t/, $d{$chr}->{$pos}); print "$h[0]\n$h[1]\n";}}' > /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest_correct.sorted.fa

# Dammit all again! Aparently they truncated the "ARS" from the probe name and prevented exact matching!
perl -lane '$_ =~ s/BFGL/ARS-BFGL/; print $_;' < ../recombination/rcmap_hits.csv > ../recombination/rcmap_hits.renamed.csv

perl -e 'chomp(@ARGV); my %h; open($IN, "< $ARGV[0]"); <$IN>; while(<$IN>){chomp; @s = split(/,/); $h{$s[0]} = [$s[1], $s[2]];} close $IN; open($IN, "< $ARGV[1]"); for(my $x = 0; $x < 9; $x++){<$IN>;} while(<$IN>){chomp; @s = split(/,/); if(exists($h{$s[1]})){$chr = $h{$s[1]}->[0]; $pos = $h{$s[1]}->[1]; print ">$s[1].$chr.$pos\t$s[5]\n";}else{print ">$s[1].$s[9].$s[10]\t$s[5]\n";}}' ../recombination/rcmap_hits.renamed.csv /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest.csv | perl -e '%d; while($l = <>){chomp $l; @s = split(/\t/, $l); @n = split(/\./, $s[0]); $d{$n[1]}->{$n[2]} = $l;} foreach my $chr (sort{$a <=> $b} keys(%d)){foreach my $pos (sort{$a <=> $b} keys(%{$d{$chr}})){ @h = split(/\t/, $d{$chr}->{$pos}); print "$h[0]\n$h[1]\n";}}' > /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest_correct.sorted.fa

```


#### condense_zero_cov_regions.pl
```perl
#!/usr/bin/perl
# A quick one-shot script designed to process a bedtools coverage bed file to identify regions of zero coverage

my $usage = "perl $0 <input bedtools coverage tab> <output zero coverage bed>\n";

chomp(@ARGV);

open(my $IN, "< $ARGV[0]") || die "$usage";
open(my $OUT, "> $ARGV[1]");
my $chr = "NA"; my $start = 0; my $end = 0; my $inzero = 0;

my $h = <$IN>;
chomp $h; my @first = split(/\t/, $h);
$chr = $first[0];
while(my $line = <$IN>){
        chomp $line;
        my @segs = split(/\t/, $line);
        if($segs[0] ne $chr){
                if($inzero){
                        print {$OUT} "$chr\t$start\t$end\n";
                        $inzero = 0;
                        $start = 0; $end = 0;
                }
                $chr = $segs[0];
        }elsif($inzero && $segs[2] != 0){
                print {$OUT} "$chr\t$start\t$end\n";
                $inzero = 0;
                $start = 0; $end = 0;
        }elsif($segs[2] == 0 && !$inzero){
                $inzero = 1;
                $start = $segs[1];
                $end = $segs[1];
        }elsif($inzero){
                $end = $segs[1];
        }
}
close $IN;

if($inzero){
        print {$OUT} "$chr\t$start\t$end\n";
}
close $OUT;
exit;
```

<a name="corr"></a>
## Cattle Assembly correction

Aleksey used Bob's guides to correct the misplaced contigs on topolish.no1b. I'm going to run his assemblies through the pipeline to see how they stack up.

> /mnt/nfs/nfs2/dbickhart/dominette_asm/revised_sv_cattle_asms

```bash
sbatch --nodes=1 --mem=6000 --ntasks-per-node=1 --wrap="module load bwa; module load samtools; wget ftp://ftp.genome.umd.edu/pub/dominette/topolish.filledWithCanuAndPBJelly.withX.no1b.4rev.6rev.8fix.7rev.9fix.11fix.13rev.14rev.16fix.16rev.18rev.19rev.20fix.21fix.23fix.24rev.26fix.29rev.fasta; mv topolish.filledWithCanuAndPBJelly.withX.no1b.4rev.6rev.8fix.7rev.9fix.11fix.13rev.14rev.16fix.16rev.18rev.19rev.20fix.21fix.23fix.24rev.26fix.29rev.fasta topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa; bwa index topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa; samtools faidx topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa"

sbatch --nodes=1 --mem=1000 --ntasks-per-node=1 --dependency=afterok:656502 --wrap="perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b nosplit -t ../dominette_run1_only_nextseq_file_list.tab -f topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa -m"

sbatch --nodes=1 --mem=6000 --ntasks-per-node=1 --wrap="module load bwa; module load samtools; wget ftp://ftp.genome.umd.edu/pub/dominette/topolish.filledWithCanuAndPBJelly.withX.no1b.4rev.6rev.8fix.7rev.9fix.11fix.13rev.14rev.16fix.16rev.18rev.19rev.20fix.21fix.23fix.24rev.26fix.29rev.split.fasta; mv topolish.filledWithCanuAndPBJelly.withX.no1b.4rev.6rev.8fix.7rev.9fix.11fix.13rev.14rev.16fix.16rev.18rev.19rev.20fix.21fix.23fix.24rev.26fix.29rev.split.fasta topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.split.fa; bwa index topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.split.fa;  samtools faidx topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.split.fa"

sbatch --nodes=1 --mem=1000 --ntasks-per-node=1 --dependency=afterok:656504 --wrap="perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b split -t ../dominette_run1_only_nextseq_file_list.tab -f topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.split.fa -m"

sbatch serge_script_oneshot.sh topolish.no1b/nosplit/dominette/dominette.sorted.merged topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa dominette
sbatch --nodes=1 --mem=15000 --ntasks-per-node=1 --wrap="module load bedtools/2.25.0; bedtools genomecov -ibam topolish.no1b/nosplit/dominette/dominette.sorted.merged.bam -bga > topolish.no1b/nosplit/dominette/dominette.sorted.merged.bedtools.cov.tab"

sbatch --dependency=afterok:656510 serge_script_oneshot.sh topolish.no1b/split/dominette/dominette.sorted.merged topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.split.fa dominette

sbatch --mem=2000 --nodes=1 --ntasks-per-node=1 --wrap="perl -lane 'if($F[3] == 0){print $_;}' < nosplit/dominette/dominette.sorted.merged.bedtools.cov.tab > nosplit/dominette/dominette.sorted.merged.bedtools.zero.cov.tab"
```

OK, I now need to correct chromosome 6 as that was the remaining error after Serge and Bob's manual edits.

<a name="three"></a>
### V1.0.3

From Bob's slack post:

> btw @dbickhart if you want to fix chr6, just replace the scaffold in aleksey's topolish from about position 113620307 to the end with canu contig tig00001238 and make the scaffold 6 start at 16698095

Serge:

> 113162819
this seems to be my last good position 
before it jumps to the 1238 tig

From the long1coords that Serge provided, it looked like tig00001238 should be aligned in reverse to the start of the 109,733,389 portion of chr6. Also, to avoid duplicating the contig, I need to remove up to the 4,651,327 bp in the beginning. I will check alignments of reads to confirm both. I need to be careful!!! The coordinates on the nucmer plot are reversed! I will check with a brief alignment of the "ends" of tig0001238 to make sure.

Another issue is chromosome X. From the alignments of Canu contigs to ChrX, it looks like there is a huge "gap" in Aleksey's X chromosome that spans tig00009294. There is also a section of tig00001361 that appears to be a "gap" in Aleksey's X. Finally, tig00001577 has an inversion. I'm going to check against the X chr mapping probes first and then align reads to each contig to check.

```bash
# mapping to Canu mhap asm
sbatch --nodes=1 --mem=20000 --ntasks-per-node=2 --wrap="module load bwa; bwa index canu.mhap.all.fasta; perl recombination/alignAndOrderSnpProbes.pl -a canu.mhap.all.fasta -p recombination/rcmap_manifest.fa -o recombination/canu.mhap.rcmap"

# Grepping contigs that I need for alignment
mkdir rdcheck
samtools faidx canu.mhap.all.fasta tig00001238 tig00009294 tig00001361 tig00001577 > rdcheck/canu_tigs_1238_9294_1361_1577.fa
sbatch --nodes=1 --mem=5000 --ntasks-per-node=1 --wrap="module load bwa; bwa index rdcheck/canu_tigs_1238_9294_1361_1577.fa"


# Fixing chr6
mkdir chr_fixing
# Testing hypothesis on contig coordinates
bwa mem topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa chr_fixing/tig00001238_orientation.fa > chr_fixing/tig00001238_orientation.sam
	tig00001238:1-1000      16      6       4650322 60
	# So the long coord file I have is correct. 	
	# remove topolish6:97,358,809-end
	# tig00001238:4684386-end  orient:-   needs to go on the beginning of the chr6 scaffold
	# tig00009764:1-end orient:- needs to go on the end of the chr6 scaffold
	
# Starting the process
samtools faidx topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa 6:1-97358809 > chr_fixing/topolish.fixed.chr6.1_97mb.fa
samtools faidx canu.mhap.all.fasta tig00001238:4684386-20561998 > chr_fixing/tig00001238_segment.fa
samtools faidx canu.mhap.all.fasta tig00009764:1-1716403 > chr_fixing/tig00009764_segment.fa

sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i tig00001238_segment.fa,topolish.fixed.chr6.1_97mb.fa,tig00009764_segment.fa -d '-,+,-' -o topolish.fixed.chr6.fixed.fa"

# Testing
samtools faidx topolish.fixed.chr6.fixed.fa 6:1000-2000 6:4000-5000 6:100000000-100001000 6:100003000-100004000 > new_chr6_test.fa
bwa mem ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa new_chr6_test.fa > new_chr6_test.sam
# So far, so good!


# Whoops! Hold the phone! Now I know why tig00009764 was broken up -- it has a misassembly with chr17 in the middle
# Just confirmed with alignment images and the recombination map
samtools faidx ../canu.mhap.all.fasta tig00009764:1-503775 > tig00009764_broken_segment2.fa
samtools faidx ../canu.mhap.all.fasta tig00009764:646287-1716403 > tig00009764_broken_segment1.fa
sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i tig00001238_segment.fa,topolish.fixed.chr6.1_97mb.fa,tig00009764_broken_segment1.fa,tig00009764_broken_segment2.fa -d '-,+,-,-' -o topolish.fixed.chr6.fixed.tig9764.fa"

# Testing the recombination map to determine if the chr is assembled correctly
sbatch --nodes=1 --mem=20000 --ntasks-per-node=2 --wrap="module load bwa; bwa index canu.mhap.all.fasta; perl recombination/alignAndOrderSnpProbes.pl -a topolish.fixed.chr6.fixed.tig9764.fa -p ../recombination/rcmap_manifest.fa -o topolish.fixed.chr6.fixed.tig9764.rcmap"

# OK, now to generate the final fasta
sbatch --nodes=1 --mem=20000 --ntasks-per-node=2 --wrap="module load bwa; bwa index topolish.fixed.chr6.fixed.tig9764.fa; perl ../recombination/alignAndOrderSnpProbes.pl -a topolish.fixed.chr6.fixed.tig9764.fa -p ../recombination/rcmap_manifest.fa -o topolish.fixed.chr6.fixed.tig9764.rcmap"

# There appears to be a flaw within tig00001238. Going to try to fix it quickly
	6       107394629       107585442       6       12834838        12636238        -       190813  198600
	6       107678393       108677334       6       2197697 1249100 -       998941  948597
	6       108756884       109835444       6       61567   1169965 +       1078560 1108398
	6       109951981       114580517       6       12501415        7908900 -       4628536 4592515

samtools faidx topolish.fixed.chr6.fixed.tig9764.fa 6:2197697-12636238 > topolish.fixed.chr6.fixed.tig9764.seg1.fa
samtools faidx topolish.fixed.chr6.fixed.tig9764.fa 6:1-1169965 > topolish.fixed.chr6.fixed.tig9764.seg2.fa
samtools faidx topolish.fixed.chr6.fixed.tig9764.fa 6:1249100-2197697 > topolish.fixed.chr6.fixed.tig9764.seg3.fa
samtools faidx topolish.fixed.chr6.fixed.tig9764.fa 6:12636238-114810314 > topolish.fixed.chr6.fixed.tig9764.seg4.fa

sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i topolish.fixed.chr6.fixed.tig9764.seg1.fa,topolish.fixed.chr6.fixed.tig9764.seg2.fa,topolish.fixed.chr6.fixed.tig9764.seg3.fa,topolish.fixed.chr6.fixed.tig9764.seg4.fa -d '+,-,+,+' -o topolish.fixed.chr6.fixed.tig9764.resegment.fa"

sbatch --nodes=1 --mem=20000 --ntasks-per-node=2 --wrap="module load bwa; bwa index topolish.fixed.chr6.fixed.tig9764.resegment.fa; perl ../recombination/alignAndOrderSnpProbes.pl -a topolish.fixed.chr6.fixed.tig9764.resegment.fa -p ../recombination/rcmap_manifest.fa -o topolish.fixxed.chr6.fixed.tig9764.resegment.rcmap"


# Parity checking with UMD3
sbatch /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/assembly_scripts/rapidAssemblyChrAlignmentComp.pl -c /mnt/nfs/nfs2/Genomes/umd3_kary_unmask_ngap.fa -j chr6 -n chr_fixing/topolish.fixed.chr6.fixed.tig9764.fa -m 6 -o chr_fixing/chr6.fixed.tig9764.umd3.comp.tab
sbatch /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/assembly_scripts/rapidAssemblyChrAlignmentComp.pl -c /mnt/nfs/nfs2/Genomes/umd3_kary_unmask_ngap.fa -j chr6 -n chr_fixing/topolish.fixed.chr6.fixed.tig9764.resegment.fa -m 6 -o chr_fixing/chr6.fixed.tig9764.resegment.umd3.comp.tab

```

Testing chr6 joining site locally

> pwd: 

```bash
perl -lane 'if($F[-1] == 6 && $F[0] >= 103583644 ){print "$F[0]\t$F[1]\t$F[2]\t$F[3]\t$F[-2]\t$F[-1]";}' < toPolishFixedVsUMD.long1coords | perl -e '$c = 99999999999; while(<>){chomp; @s = split(/\t/); if($s[2] < $c){$c = $s[2];} if($s[3] < $c){$c = $s[3]}} print "$c\n";'
101,794,133 <- lowest coordinate on chr6 topolish that maps before the break in UMD3

# Canu alignments in the region
# canu start	end				topolishstart	end				canu		topolish
#4430139		 4636418 		207602  		1196    		tig00001238     6
#4684386		 4778294 		109732733       109638725       tig00001238     6
#12438116        12589926        101927289       101775379       tig00001238     6
#12602754        12661935        101762438       **101703071**       tig00001238     6

# Decision time! I'm going to clip at the canu alignment point because: 
# (A) it's further down the scaffold and (b) it is the first point on the scaffold that encompasses the contig

# New info on the scaffold:
grep 'tig00009764' toPolishFixedVsCanu.long1coords
17195   243277  97874325        97647946        226083  226380  99.69   1716403 118271633       13.17   0.19    tig00009764     6
253491  353408  97637095        97536971        99918   100125  99.69   1716403 118271633       5.82    0.08    tig00009764     6
371604  530882  97518207        97358809        159279  159399  99.84   1716403 118271633       9.28    0.13    tig00009764     6
516824  640797  68269511        68145464        123974  124048  99.77   1716403 73196606        7.22    0.17    tig00009764     17
641983  752892  101420619       101309680       110910  110940  99.96   1716403 118271633       6.46    0.09    tig00009764     6
759484  914975  101303111       101147546       155492  155566  99.92   1716403 118271633       9.06    0.13    tig00009764     6
922504  1045799 101140028       101016649       123296  123380  99.89   1716403 118271633       7.18    0.10    tig00009764     6
1064989 1678373 100997497       100383750       613385  613748  99.87   1716403 118271633       35.74   0.52    tig00009764     6

# OK, so tig00009764 looks to be better. I'll start my clipping at the 97358809 start site instead
```

Bob sent a huge linkage map file. I'm going to reorder and reorganize the assembly based on that information and Aleksey's "split" ASM instead. This will keep things tidy and easier to resolve downstream.


> fry: /mnt/nfs/nfs2/dbickhart/dominette_asm/bob_reorder

```bash
sbatch ../recombination/alignAndOrderSnpProbes.pl -a ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.split.fa -p ../recombination/rcmap_manifest.fa -o topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.split.rcmap

perl -ne 'if($_ =~ /^>/){$_ =~ s/\:/\_/g; print $_;}else{print $_;}' <  ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.split.fa > topolish.fixed.split.fa

# Chr6 
# 6:9 -, 6:11 -, 6:7 -, 6:5 -, 6:4 -, 6:3 -, 6:2 -, 6:1 -, 6:16 -, 6:15 -, 6:17 -, 
# The inversion is on 6:17, so I can fix it there or post creation
# In the folder, each chr 6 "segment" from the split fasta is represented by a "segment" fasta

sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr6_seg9.fa,chr6_seg11.fa,chr6_seg7.fa,chr6_seg5.fa,chr6_seg4.fa,chr6_seg3.fa,chr6_seg2.fa,chr6_seg1.fa,chr6_seg16.fa,chr6_seg15.fa,chr6_seg17.fa -d '-,-,-,-,-,-,-,-,-,-,-' -o chr6_correctlkrh_order.fa"

# That failed miserably! The lc map is missing several segments of chr6. Far better for me to salvage the previous version
# segments: tig00001238:1-7642766  tig00001238:17422149-18185848 tig00001238:7747445-7925712 tig00001238:18364253-19312850 tig00001238:20500383-19391985 -, tig00001238:8060536-17357033
samtools faidx canu.mhap.all.fasta tig00001238:4684386-7642766 > chr_fixing/tig1238_seg1.fa
samtools faidx canu.mhap.all.fasta tig00001238:17422149-18185848 > chr_fixing/tig1238_seg2.fa
samtools faidx canu.mhap.all.fasta tig00001238:7747445-7925712 > chr_fixing/tig1238_seg3.fa
samtools faidx canu.mhap.all.fasta tig00001238:18364253-19312850 > chr_fixing/tig1238_seg4.fa
samtools faidx canu.mhap.all.fasta tig00001238:19391985-20500383 > chr_fixing/tig1238_seg5.fa
samtools faidx canu.mhap.all.fasta tig00001238:8060536-17357033 > chr_fixing/tig1238_seg6.fa

sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr6_order_list.tab -o topolish.fixed.chr6.remapinv.fa -p 100"
sbatch process_and_qv_fasta.sh topolish.fixed.chr6.remapinv.fa
# Looks good, but the entire chromosome needs to be inverted. Going to do that

# Chr16
# There is a piece of the telomere that needs to be replaced
# Going to try to finemap it with the recombination map
samtools faidx ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa 16 > topolish.unfixed.chr16.fa
sbatch run_rcmap_only.sh topolish.unfixed.chr16.fa
# segments: 16:1-48410975 16:48796030-80254284 16:48411025-48594326
samtools faidx topolish.unfixed.chr16.fa 16:1-48410975 > chr16_seq1.fa
samtools faidx topolish.unfixed.chr16.fa 16:48796030-80254284 > chr16_seq2.fa
samtools faidx topolish.unfixed.chr16.fa 16:48411025-48594326 > chr16_seq3.fa

sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr16_order_list.tab -o topolish.fixed.chr16.revmap.fa -p 100"
sbatch --dependency=afterok:658056 process_and_qv_fasta.sh topolish.fixed.chr16.revmap.fa

# Chr20
# There is a small portion that needs to be remapped 
samtools faidx ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa 20 > topolish.unfixed.chr20.fa
sbatch run_rcmap_only.sh topolish.unfixed.chr20.fa
# Bob was right, looks like an inversion too
# segments: 20:373977-25698557, 20:1-373976 -, 20:25803664-71933398
samtools faidx topolish.unfixed.chr20.fa 20:373977-25698557 > chr20_seq1.fa
samtools faidx topolish.unfixed.chr20.fa 20:1-373976 > chr20_seq2.fa
samtools faidx topolish.unfixed.chr20.fa 20:25803664-71933398 > chr20_seq3.fa

sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr20_order.list.tab -o topolish.fixed.chr20.revmap.fa -p 100"
sbatch --dependency=afterok:658059 process_and_qv_fasta.sh topolish.fixed.chr20.revmap.fa

# Chr23
samtools faidx ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa 23 > topolish.unfixed.chr23.fa
sbatch run_rcmap_only.sh topolish.unfixed.chr23.fa
# Bob lists the middle portion as erroneous, but it's confirmed by the recmap as well
# Segments: 23:30762598-31126683 -, 23:31126682-52298066 -, 23:1-307625597 -
samtools faidx topolish.unfixed.chr23.fa 23:30762598-31126683 > chr23_seq1.fa
samtools faidx topolish.unfixed.chr23.fa 23:31126682-52298066 > chr23_seq2.fa
samtools faidx topolish.unfixed.chr23.fa 23:1-30762597 > chr23_seq3.fa

sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr23_order.list.tab -o topolish.fixed.chr23.revmap.fa -p 100"
sbatch --dependency=afterok:658062 process_and_qv_fasta.sh topolish.fixed.chr23.revmap.fa

# ChrX
# Bob found a few RH markers that are not supposed to be on X. I'll try to fix them
samtools faidx ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa X > topolish.unfixed.chrX.fa
sbatch run_rcmap_only.sh topolish.unfixed.chrX.fa
# Actually, Bob says that the X is likely ok. We'll leave it for now.

# Reorienting fastas
# I just need to invert the following chrs:
samtools faidx ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa 7 > topolish.unfixed.chr7.fa
samtools faidx ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa 9 > topolish.unfixed.chr9.fa
samtools faidx ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa 18 > topolish.unfixed.chr18.fa
samtools faidx ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa 21 > topolish.unfixed.chr21.fa
samtools faidx ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa 24 > topolish.unfixed.chr24.fa

for i in chr7 chr9 chr18 chr21 chr24; do sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i ${i}_order_list.tab -o topolish.fixed.${i}.revmap.fa"; done

# Finally, gluing together all of the pieces
ls topolish.fixed.chr*.fa > correction_fastas.list
vim correction_fastas.list # Final edits of fastas that I want to incorporate
sbatch ../chr_fixing/reorder_fasta.pl ARS-UCD1.0.3.fa ../topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa correction_fastas.list
sbatch process_and_qv_fasta.sh ARS-UCD1.0.3.fa
```


#### process_and_qv_fasta.sh

```bash
#!/usr/bin/bash
#SBATCH --nodes=1
#SBATCH --mem=10000
#SBATCH --ntasks-per-node=2
# $1 = input fasta file

module load samtools
module load bwa
module load java/jdk1.8.0_92

alignrcscript=/mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl
alignrcmanifest=/mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest.fa
gapfastagen=/mnt/nfs/nfs2/bickhart-users/binaries/GetMaskBedFasta/store/GetMaskBedFasta.jar

gapbed=${1}.gap.bed
gapstats=${1}.gap.stats
rcmap=${1}.rcmap

samtools faidx $1
bwa index $1
perl $alignrcscript -a $1 -p $alignrcmanifest -o $rcmap
java -Xmx10g -jar $gapfastagen -f $1 -o $gapbed -s $gapstats
```

#### alignAndOrderSnpProbes.pl

```perl
#!/usr/bin/perl
#SBATCH --nodes=1
#SBATCH --mem=10000
#SBATCH --ntasks-per-node=1
# This is a one-shot script designed to map and order SNP probes from the recombination map to a new assembly
# Output: base.tab <- snpnames and mapping coordinates
# Output: base.segs <- identified chromosome segments
# Output: base.conflicts <- conflicting segments
# Output: base.stats <- general statistics

use strict;
use Getopt::Std;

my $usage = "perl $0 (-a <assembly fasta> -p <probe fasta>) || (-n <nucmer aligns>) -o <output file basename>\n";
my %opts;
getopt('apon', \%opts);

unless(((defined($opts{'a'}) && defined($opts{'p'})) || defined($opts{'n'})) && defined($opts{'o'})){
        print $usage;
        exit;
}

my $unmaps = 0; my $maps = 0;
my %aligns; # {ochr}->{opos} = [probe, chr, pos, orient]

if(defined($opts{'a'})){
open(my $IN, "module load bwa; bwa mem $opts{a} $opts{p} |") || die "Could not begin BWA alignments!\n";
while(my $line = <$IN>){
        if($line =~ /^@/){
                next;
        }

        chomp $line;
        my @segs = split(/\t/, $line);
        my @rnsegs = split(/\./, $segs[0]);
        if($segs[1] & 2048){
                next;
        }
        if($rnsegs[1] == 0){next;} # Takes care of probes without prior chromosome alignments
        if($segs[2] eq "*"){
                $unmaps++; # Count unmapped probes
        }else{
                $maps++;
        }
        my $orient = ($segs[1] & 16)? "-" : "+";
        $aligns{$rnsegs[1]}->{$rnsegs[2]} = [$rnsegs[0], $segs[2], $segs[3], $orient];
}
close $IN;
}elsif(defined($opts{'n'})){
        open(my $IN, "< $opts{n}") || die "Could not open nucmer aligns!\n";
        while(my $line = <$IN>){
                chomp $line;
                my @segs = split(/\t/, $line);
                $maps++;
                my $orient = ($segs[2] > $segs[3])? "-" : "+";
                $aligns{$segs[11]}->{$segs[0]} = ["none", $segs[12], $segs[2], $orient];
        }
        close $IN;
}

open(my $OUT, "> $opts{o}.tab");
open(my $STATS, "> $opts{o}.stats");
open(my $SEGS, "> $opts{o}.segs");
print {$STATS} "Mapping probes: $maps\tUnmapped probes: $unmaps\n";
foreach my $chr (sort{$a <=> $b} keys(%aligns)){
        my ($consensus, $values) = determineConsensus($aligns{$chr});
        print {$STATS} "Ref $chr consensus:";
        for (my $x = 0; $x < scalar(@{$consensus}); $x++){
                print {$STATS} " $consensus->[$x]:$values->[$x]";
        }
        print {$STATS} "\n";

        my ($refblocks, $qblocks) = identifyAndCondenseSegs($aligns{$chr}, $consensus->[0]);
        for(my $x = 0; $x < scalar(@{$refblocks}); $x++){
                my $ref = $refblocks->[$x];
                my $query = $qblocks->[$x];
                my $rlen = abs($ref->[1] - $ref->[0]);
                my $qlen = abs($query->[0] - $query->[1]);
                my $orient = ($query->[0] < $query->[1])? "+" : "-";
                print {$SEGS} "$chr\t$ref->[0]\t$ref->[1]\t$query->[2]\t$query->[0]\t$query->[1]\t$orient\t$rlen\t$qlen\n";
        }

        foreach my $pos (sort{$a <=> $b} keys(%{$aligns{$chr}})){
                my $arrayref = $aligns{$chr}->{$pos};
                print {$OUT} join("\t", @{$arrayref});
                print {$OUT} "\t$chr\t$pos\n";
        }
}
close $OUT;

exit;

sub identifyAndCondenseSegs{
        my ($hashref, $consensus) = @_;
        # Logic: tolerate one deviation in consensus, otherwise condense region into a block
        my @refblock; # [start, end]
        my @queryblock; # [start, end, chr, testbit]

        my @buff; my $count = 0; my $segs = 0; my $skip = 0;
        foreach my $pos (sort{$a <=> $b} keys(%{$hashref})){
                my $query = $hashref->{$pos};
                if($query->[1] eq "*"){next;} # skip unmapped segs
                push(@buff, [$pos, $query]);
                if($count < 2){
                        $count++;
                        # Fill the initial container buffer
                        next;
                }

                if(scalar(@refblock) - 1 < $segs){
                        # starting a new segment
                        push(@refblock, [$buff[0]->[0], $buff[0]->[0]]);
                        push(@queryblock, [$buff[0]->[1]->[2], $buff[0]->[1]->[2], $buff[0]->[1]->[1]]);
                }

                # Test two consecutive probes in the middle of the window to see if they match expectations
                my $comparator = $buff[0]->[1];
                my $test1 = $buff[1]->[1];
                my $test2 = $buff[2]->[1];
                # avg pairwise distance between reference probes in this view
                my $refDist = (($buff[1]->[0] - $buff[0]->[0]) + ($buff[2]->[0] - $buff[1]->[0])) / 2;
                my $t1dist = abs($test1->[2] - $comparator->[2]);
                my $t2dist = abs($test2->[2] - $comparator->[2]);

                if($skip){
                        $skip = 0;
                }else{
                        # passed the test bit for singleton deviations in consensus
                        if(($t1dist > 5 * $refDist && $t2dist > 5 * $refDist) ||
                                ($test1->[1] ne $consensus && $test2->[1] ne $consensus)){
                                $segs++; # The conditional now knows to start a new segment
                        }elsif($t1dist > 5 * $refDist || $test1->[1] ne $consensus){
                                # We don't want singletons to screw up our segments
                                $skip = 1;
                        }
                        # Update the current segments
                        $refblock[-1]->[1] = $buff[0]->[0];
                        $queryblock[-1]->[1] = $buff[0]->[1]->[2];
                }

                shift(@buff); # Remove the preceeding buffer item
        }
        if(scalar(@buff) < 3 && scalar(@refblock) < 1){
                # For alignments with fewer lines than chromosomes
                push(@refblock, [$buff[0]->[0], $buff[0]->[0]]);
                push(@queryblock, [$buff[0]->[1]->[2], $buff[0]->[1]->[2], $buff[0]->[1]->[1]]);
                if(scalar(@buff) > 1){
                        if($buff[1]->[1]->[2] eq $consensus){
                                $refblock[0]->[1] = $buff[1]->[0];
                                $queryblock[0]->[1] = $buff[1]->[1]->[2];
                        }else{
                                push(@refblock, [$buff[1]->[0], $buff[1]->[0]]);
                                push(@queryblock, [$buff[1]->[1]->[2], $buff[1]->[1]->[2], $buff[1]->[1]->[1]]);
                        }
                }
        }else{
        # Update the final segments for this chr
        $refblock[-1]->[1] = $buff[-1]->[0];
        $queryblock[-1]->[1] = $buff[-1]->[1]->[2];
        }

        return \@refblock, \@queryblock;
}



sub determineConsensus{
        my ($hashref) = @_;
        # The input is all of the mapped probes from a reference chr
        # All we need to do is to determine the highest mapping percentile chr from the mapping chr
        my %chrs;
        foreach my $pos (keys(%{$hashref})){
                $chrs{$hashref->{$pos}->[1]} += 1;
        }
        my @consensus = sort{$chrs{$b} <=> $chrs{$a}} keys(%chrs);
        my @values = map{$chrs{$_}} @consensus;
        return \@consensus, \@values;
}
```
<a name="four"></a>
### ARS-UCD1.0.4 creation

Using Bob's guidelines and a few more problem regions identified from my scan of the rcmap.

> fry:/mnt/nfs/nfs2/dbickhart/dominette_asm/chr_fixing/ver_4_corrections

```bash
# Let's grep out all of the chromosomes I need
samtools faidx ../ARS-UCD1.0.3.fa 21 > ver_3_21.fa
samtools faidx ../ARS-UCD1.0.3.fa 27 > ver_3_27.fa
samtools faidx ../ARS-UCD1.0.3.fa 2 > ver_3_2.fa
samtools faidx ../ARS-UCD1.0.3.fa 10 > ver_3_10.fa
samtools faidx ../ARS-UCD1.0.3.fa 9 > ver_3_9.fa
for i in `ls *.fa`; do echo $i; samtools faidx $i; done

# chr21
# Region: 21:33382423-34381237  
# Should be inverted and placed further up the chromosome.
# RCmap positions and canu contig confirmed
# chr21: Segments: 21:1-33382000: +, , 21:34471679-60613291: +, 21:33382423-34381237: -, 21:60613291-71144717
samtools faidx ver_3_21.fa 21:1-33382000 > chr21_seg1.fa
samtools faidx ver_3_21.fa 21:34471679-60613291 > chr21_seg2.fa
samtools faidx ver_3_21.fa 21:33382423-34381237 > chr21_seg3.fa
samtools faidx ver_3_21.fa 21:60613291-71144717 > chr21_seg4.fa
sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr21_order.list.tab -o version_4_fixed_chr21.fa -p 100"

# chr27
# Segment belongs on chr27
# ARS-BFGL-NGS-91530      21      34418807        +       27      36664
# Segments: 21:34386001-34435280:+ to chr27, beginning of chromosome
# considering confirmed as it fits in with another inversion discovered by the rcmap
# chr27: 21:34386001-34435280:+ 27:1-end:+
samtools faidx ver_3_21.fa 21:34386001-34435280 > chr27_seg1.fa 
sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr27_order.list.tab -o version_4_fixed_chr27.fa -p 100"

# chr2
# ARS-BFGL-NGS-52539      2       121810158       +       10      18743955
# Here's the area on chr2
#ARS-BFGL-NGS-28919      2       121315884       -       2       122146355
#ARS-BFGL-NGS-40444      2       121967868       -       2       122409628
# Our chr difference: 600kb, UMD3: 300kb. Difficult to break
# Trusting in Bob's dbsnp mappings here
# chr2: chr2:1-121673581: + chr2:121843925-end
samtools faidx ver_3_2.fa 2:1-121673581 > chr2_seg1.fa
samtools faidx ver_3_2.fa 2:121843925-136330933 > chr2_seg2.fa
sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr2_order.list.tab -o version_4_fixed_chr2.fa -p 100"

# chr10
# segments:
# chr10: 10:1-18651720:+, 2:121708673-121823734:+, 10:18853496-end
samtools faidx ver_3_10.fa 10:1-18651720 > chr10_seg1.fa
samtools faidx ver_3_2.fa 2:121708673-121823734 > chr10_seg2.fa
samtools faidx ver_3_10.fa 10:18853496-103693712 > chr10_seg3.fa
sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr10_order.list.tab -o version_4_fixed_chr10.fa -p 100"

# chr9
# I have no X markers and no other linkage information. My plan is just to remove the region and place it as a "special"
# leftover contig
# segments:
# chr9: 9:1-104017834:+ 9:112550012-end:+, 9:104017834-112550012 to contig_x_unplaced.
samtools faidx ver_3_9.fa 9:1-104017834 >chr9_seg1.fa
samtools faidx ver_3_9.fa 9:112550012-113852591 > chr9_seg2.fa
samtools faidx ver_3_9.fa 9:104017834-112550012 > extra_9_contig.fa
sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr9_order.list.tab -o version_4_fixed_chr9.fa -p 100"

# Now stitching together most of the autosomes
sbatch ../reorder_fasta.pl ARS_UCDpreV4.fa ../ARS-UCD1.0.3.fa correction_fastas.v4.list
# Adding the unplaced X chromosome contig
cat ARS_UCDpreV4.fa extra_9_contig.fa > ../ARS-UCD1.0.4.fa
sbatch --nodes=1 --mem=1000 --ntasks-per-node=1 --wrap="samtools faidx ARS-UCD1.0.4.fa; gzip ARS-UCD1.0.4.fa;"

# Reversing orientation based on Bob's May 17th Pbjelly comparison
perl -lane 'if($F[1] eq "-"){open(OUT, "> temp.tab"); print OUT "$F[0]\t$F[1]"; close OUT; system("java -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i temp.tab -o $F[0].rev -p 100");}' < pilon_fasta_list.tab

perl -lane 'system("cat $F[0] >> ../ars_ucd_112/v12_asm_pilonheads.fa");' < pilon_fasta_list.tab
```

Summary: made corrections to 5 chromosomes from ARS-UCD1.0.3.fa. 

* chr2: removed 2:121708673-121823734 and added it to the middle of chr10
* chr21: 
	* removed 21:33382423-34381237 and moved it to the beginning of chr27
	* inverted and moved 21:33382423-34381237 further down the chromosome
* chr9: removed 9:104017834-112550012 and placed it in "contig_x_unplaced"
* chr10: see above
* chr27: see above

<a name="five"></a>
### ARS-UCD1.0.5 creation

A bunch of remaining issues to address and some leftover scaffolds to place.

> fry: /mnt/nfs/nfs2/dbickhart/dominette_asm/chr_fixing/ver_5_corrections

```bash
# Leftovers
# Intersecting the rough coordinates of the Leftover contig insertions with gaps
# This is the easiest way to incorporate them into the ASM without causing more headaches!
intersectBed -a leftover_regions.1.0.3.bed -b ARS-UCD1.0.3.fa.gap.bed
19      43249193        43249217        Leftover_ScbfJmS_1654

# Chr6
# There are errors on the beginning and end of the chromosome
# Also, there is a missing portion near the beginning, from UMD_6:1471923-3780334
# The chr6 situation is pretty complex actually:
# End of the chr:
	BTA-77952-no-rs *       0       +       6       119396306
	Hapmap46942-BTA-114876  6       102019559       +       6       126619789
	BTB-01782372    6       102377773       +       6       126981782
	BTB-01534933    6       102824316       -       6       127576198
	Hapmap44179-BTA-102481  6       102876193       -       6       127720898
	BTB-01544044    6       102898160       +       6       127742938
	Hapmap43685-BTA-77920   6       103146861       +       6       128026956
	BTA-09585-no-rs 6       103246085       -       6       128135281
	Hapmap55617-rs29025460  6       103672694       +       6       128567814
	Hapmap53146-ss46526085  6       104115364       +       6       129056666
	BTB-00284077    6       104254666       +       6       129209793
	BTB-00283603    6       104773093       -       6       129719477
# Supposed breakpoint:
	ARS-BFGL-NGS-83571      6       101891483       +       6       106495683
	ARS-BFGL-NGS-111057     6       101912902       -       6       106517122
	ARS-BFGL-NGS-1012       6       101946553       +       6       106546711
	BovineHD0600029934      6       101951972       +       6       106552130
	ARS-BFGL-NGS-79719      6       101978733       +       6       106578932
	BovineHD0600029951      6       102007520       -       6       106607689
	ARS-BFGL-NGS-112900     6       102046963       -       6       106647592
	BovineHD0600029975      6       102102018       +       6       106703398
	ARS-BFGL-NGS-112084     6       102157017       +       6       106758901
	BovineHD0600030003      6       102184676       -       6       106786536
	ARS-BFGL-NGS-28350      6       102206464       +       6       106808225

# Based on Bob's linkage map, The early-102 fragments appear to be a separate block
# Let's be conservative and link only the regions that have consensus recmap and linkage map positioning
# Segments:
# 6:1643535-2914396 :+, 6:1-1354912 +, 6:3125221-101848529 +, 6:104959826-114187345 +, 6:102019559-104831017 +
samtools faidx ../ARS-UCD1.0.4.fa 6:1643535-2914396 > chr6_seg1.fa
samtools faidx ../ARS-UCD1.0.4.fa 6:1-1354912 > chr6_seg2.fa
samtools faidx ../ARS-UCD1.0.4.fa 6:3125221-101848529 > chr6_seg3.fa
samtools faidx ../ARS-UCD1.0.4.fa 6:104959826-114187345 > chr6_seg4.fa
samtools faidx ../ARS-UCD1.0.4.fa 6:102019559-104831017 > chr6_seg5.fa

# Chr7
# This is based on coordinates from ARS-UCD1.0.3, so I need to replicate results here
# Chr7 is an easy fix because it was not modified in 1.0.3
# Bob's linkage map and the recmap are a bit fuzzy as to the placement of the chr10 segment. I will be a bit 
# conservative here as well
# segments:
# 7:1-109601269 +, 7:109766892-109870666 +, 10:93631977-94139219 +
# I saved the last "chunk" of chr7 instead of discarding it
samtools faidx ../ARS-UCD1.0.3.fa 7:1-109601269 > chr7_seg1.fa
samtools faidx ../ARS-UCD1.0.3.fa 7:109766892-109870666 > chr7_seg2.fa
samtools faidx ../ARS-UCD1.0.3.fa 10:93631977-94139219 > chr7_seg3.fa

# Chr10
# I need to redo the ARS-UCD v3 recipe for this chromosome
# ARS_UCD-1.0.3 coords!!
# segments:
# chr10: 10:1-18853496 +, 2:121708673-121823734:+, 10:18853496-93553629, 10:94259680-103693712:+
samtools faidx ../ARS-UCD1.0.3.fa 10:1-18853496 > chr10_seg1.fa
samtools faidx ../ARS-UCD1.0.3.fa 2:121708673-121823734 > chr10_seg2.fa
samtools faidx ../ARS-UCD1.0.3.fa 10:18853496-93553629 > chr10_seg3.fa
samtools faidx ../ARS-UCD1.0.3.fa 10:94259680-103693712 > chr10_seg4.fa

# Chr26
# There is a chunk that needs to be moved to around the 38 mb region.
# 26:2664716-3081519 + belongs between 26:24034259 and 26:24055998 according to the recmap
# But there is also evidence that it belongs somewhere between 50734383 and 50756585 from a probe on the recmap and most of the linkage map
# I'll go with the linkage map here and hope for the best
# segments:
# 26:1-2628677 +, 26:3172062-50734383 +, 26:2664716-3081519 +, 26:50756585-51553036 +
samtools faidx ../ARS-UCD1.0.4.fa 26:1-2628677 > chr26_seg1.fa
samtools faidx ../ARS-UCD1.0.4.fa 26:3172062-50734383 > chr26_seg2.fa
samtools faidx ../ARS-UCD1.0.4.fa 26:2664716-3081519 > chr26_seg3.fa
samtools faidx ../ARS-UCD1.0.4.fa 26:50756585-51553036 > chr26_seg4.fa

# Chr19
# This is a new addition
# Lack of information may mean that the orientation is wrong on my insertion -- we'll have to live with it!
# Segments:
# 19:1-43249193 +, Leftover_ScbfJmS_1654 +, 19:43249217-63373019 +
samtools faidx ../ARS-UCD1.0.4.fa 19:1-43249193 > chr19_seg1.fa
samtools faidx ../ARS-UCD1.0.4.fa Leftover_ScbfJmS_1654 > chr19_seg2.fa
samtools faidx ../ARS-UCD1.0.4.fa 19:43249217-63373019 > chr19_seg3.fa

# Generating order files
perl -e '@fs = `ls *.fa`; foreach $f (@fs){print $f; chomp $f; ($c) = $f =~ /(chr.+)_seg.+.fa/; open($OUT, ">> $c.order.list"); print {$OUT} "$f\t+\n"; close $OUT;}'
# Submitting revision fasta entries
for i in `ls *order.list`; do chr=`echo $i | cut -d'.' -f1`; echo $chr; sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i $i -o version_5_fixed_${chr}.fa -p 100"; done

ls version_*.fa > correction_fastas.v5.list
# I added Leftover_ScbfJmS_1654 to a removal list so that it isn't duplicated in the v5 assembly
sbatch ../reorder_fasta.pl ../ARS-UCD1.0.5.fa ../ARS-UCD1.0.4.fa correction_fastas.v5.list

# So, this should be the 1.0.4 changes as well as the updated chromosomes above
```

Summary: made changes to 5 chromosomes using a combination of v3 and v4 fasta information

* chr10: section from chr2 is placed properly, removed the portion that is the telomere for chr7
* chr7: added the telomeric portion from chr10 to the end of this chr. Also, resectioned portions of the sub-telomeric region
* chr6: fixed a translocation in the beginning of the chr and shuffled the end to match the recmap coordinates
* chr26: moved the misplaced chunk from the 24 Mb to the subtelomeric region. Recmap coordinates were mixed on the placement of this section -- trusted the linkage map here
* chr19: placed Leftover_ScbfJmS_1654 into a gap region near the 43 Mb

<a name="six"></a>
### ARS-UCD1.0.6 creation

There are still some remaining issues with chr26 that need to be addressed. I will do my best to catalogue and fix them.

```bash
mkdir ver_6_corrections
cd ver_6_corrections
# chr26
# 26:50191200-50579551  between 23490975 and 23512714
# 26:15016528-15315313:- between 25749185 and 25818753
# 26:15349938-15465426:- between 50050681 and 50119386
# segments:
# 26:1-15016528:+, 26:15465426-23490975:+, 26:50191200-50579551:+, 26:23512714-25749185:+, 26:15016528-15315313:-, 26:25818753-50050681:+, 26:15349938-15465426:-, 26:50050681-50119386:+, 26:50953848-51404555:-, 26:50119386-50856968:+
samtools faidx ../ARS-UCD1.0.5.fa 26:1-15016528 > chr26_seg1.fa
samtools faidx ../ARS-UCD1.0.5.fa 26:15465426-23490975 > chr26_seg2.fa
samtools faidx ../ARS-UCD1.0.5.fa 26:50191200-50579551 > chr26_seg3.fa
samtools faidx ../ARS-UCD1.0.5.fa 26:23512714-25749185 > chr26_seg4.fa
samtools faidx ../ARS-UCD1.0.5.fa 26:15016528-15315313 > chr26_seg5.fa
samtools faidx ../ARS-UCD1.0.5.fa 26:25818753-50050681 > chr26_seg6.fa
samtools faidx ../ARS-UCD1.0.5.fa 26:15349938-15465426 > chr26_seg7.fa
samtools faidx ../ARS-UCD1.0.5.fa 26:50050681-50119386 > chr26_seg8.fa
samtools faidx ../ARS-UCD1.0.5.fa 26:50953848-51404555 > chr26_seg9.fa
samtools faidx ../ARS-UCD1.0.5.fa 26:50119386-50856968 > chr26_seg10.fa

# chr5
# There's one inversion remaining
# segments:
# 5:1-79055811:+, 5:79055811-79460974:-, 5:79460974-120000469
samtools faidx ../ARS-UCD1.0.5.fa 5:1-79055811 > chr5_seg1.fa
samtools faidx ../ARS-UCD1.0.5.fa 5:79055811-79460974 > chr5_seg2.fa
samtools faidx ../ARS-UCD1.0.5.fa 5:79460974-120000469 > chr5_seg3.fa

# chr8
# There's one inversion remaining
# segments:
# 8:1-87651142:+, 8:87651142-87861659:-, 8:87861659-113220712:+
samtools faidx ../ARS-UCD1.0.5.fa 8:1-87651142 > chr8_seg1.fa
samtools faidx ../ARS-UCD1.0.5.fa 8:87651142-87861659 > chr8_seg2.fa
samtools faidx ../ARS-UCD1.0.5.fa 8:87861659-113220712 > chr8_seg3.fa

# chr18
# There's one inversion remaining
# segments:
# 18:1-62366442:+, 18:62366442-62533251:-, 18:62533251-65953167:+
samtools faidx ../ARS-UCD1.0.5.fa 18:1-62366442 > chr18_seg1.fa
samtools faidx ../ARS-UCD1.0.5.fa 18:62366442-62533251 > chr18_seg2.fa
samtools faidx ../ARS-UCD1.0.5.fa 18:62533251-65953167 > chr18_seg3.fa

# chr21/27
# There's still a problem where the middle of chr21 should be on the centromeric end of chr27
# chr27
# segments:
# 21:59921624-60423769:-, 27:1-44587378:+
# chr21
# segments:
# 21:1-59921624:+ 21:60423769-71054155:+
samtools faidx ../ARS-UCD1.0.5.fa 21:59921624-60423769 > chr27_seg1.fa
samtools faidx ../ARS-UCD1.0.5.fa 27:1-44587378 > chr27_seg2.fa

samtools faidx ../ARS-UCD1.0.5.fa 21:1-59921624 > chr21_seg1.fa
samtools faidx ../ARS-UCD1.0.5.fa 21:60423769-71054155 > chr21_seg2.fa


# Now to generate the intermediary order files
perl -e '@fs = `ls *.fa`; foreach $f (@fs){print $f; chomp $f; ($c) = $f =~ /(chr.+)_seg.+.fa/; open($OUT, ">> $c.order.list"); print {$OUT} "$f\t+\n"; close $OUT;}'
# Submitting version 6 corrections
for i in `ls *order.list`; do chr=`echo $i | cut -d'.' -f1`; echo $chr; sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i $i -o version_6_fixed_${chr}.fa -p 100"; done

# Wrapping it all together
ls version_6_fixed_chr*.fa > correction_fastas.v6.list
sbatch ../reorder_fasta.pl ../ARS-UCD1.0.6.fa ../ARS-UCD1.0.5.fa correction_fastas.v6.list

sbatch --dependency=afterok:658590 --nodes=1 --mem=4000 --ntasks-per-node=1 --wrap="samtools faidx ARS-UCD1.0.6.fa; gzip ARS-UCD1.0.6.fa;"

sbatch --mem=1000 --nodes=1 --ntasks-per-node=1 --wrap="gunzip ARS-UCD1.0.6.fa.gz"
sbatch --dependency=afterok:659517 ../bob_reorder/process_and_qv_fasta.sh ARS-UCD1.0.6.fa
```

Summary:

* chr21/27: moved 60mb region of chr21 to the centromere of chr27. Resectioned chr21 to remove the portion
* chr18: fixed an inversion in the recmap
* chr8: fixed an inversion in the recmap
* chr5: fixed an inversion in the recmap
* chr26: fixed 3 translocations identified in the recmap

<a name="seven"></a>
### ARS-UCD version 1.0.7

Just a few remaining issues and a cleanup of the X chromosome.

> fry: /mnt/nfs/nfs2/dbickhart/dominette_asm/chr_fixing/ver_7_corrections

```bash
# chr26
# segments
# 26:1-23042279:+, 26:23378404-50280000:+, 26:23147752-23375335:+ 26:50280080-end:+
samtools faidx ../ARS-UCD1.0.6.fa 26:1-23042279 > chr26_seg1.fa
samtools faidx ../ARS-UCD1.0.6.fa 26:23378404-50280000 > chr26_seg2.fa
samtools faidx ../ARS-UCD1.0.6.fa 26:23147752-23375335 > chr26_seg3.fa
samtools faidx ../ARS-UCD1.0.6.fa 26:50280080-51571003 > chr26_seg4.fa

# chr21/27
# There is a small portion that I missed with my last cropping. 
# chr27
# segments
# 27:1-476547:+, 21:59579708-59921726:-, 27:535053-45089624:+
# chr21
# segments:
# 21:1-59501475:+, 21:60203895-70552111
samtools faidx ../ARS-UCD1.0.6.fa 27:1-476547 > chr27_seg1.fa
samtools faidx ../ARS-UCD1.0.6.fa 21:59579708-59921726 > chr27_seg2.fa
samtools faidx ../ARS-UCD1.0.6.fa 27:535053-45089624 > chr27_seg3.fa

samtools faidx ../ARS-UCD1.0.6.fa 21:1-59501475 > chr21_seg1.fa
samtools faidx ../ARS-UCD1.0.6.fa 21:60203895-70552111 > chr21_seg2.fa

# chrX
# I need to invert the entire thing
# I will leave the unplaced x contig for now -- hopefully the Hi-C data will provide guidance here

# Generating the order lists
perl -e '@fs = `ls *.fa`; foreach $f (@fs){print $f; chomp $f; ($c) = $f =~ /(chr.+)_seg.+.fa/; open($OUT, ">> $c.order.list"); print {$OUT} "$f\t+\n"; close $OUT;}'
# Submitting version7 fixes
for i in `ls *order.list`; do chr=`echo $i | cut -d'.' -f1`; echo $chr; sbatch --nodes=1 --mem=50000 --ntasks-per-node=4 --wrap="module load java/jdk1.8.0_92; java -Xmx49g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i $i -o version_7_fixed_${chr}.fa -p 100"; done

```
The autosome corrections are ready, but they're minor and we decided to delay the creation of this assembly fasta until the Hi-C data comes in. The big question is what to do with the X chromosome, as the linkage map and recombination map are little help here, and it is very difficult to assemble.

<a name="eight"></a>
## ARS-UCD version 1.0.8

This is placement of a large portion of a canu-assembled contig on the X chromosome and the inversion of the X. I think that we're done after this.

> fry: /mnt/nfs/nfs2/dbickhart/dominette_asm/chr_fixing/ver_8_corrections

```bash
# ChrX
# I just need to separate the X chromosome and reattach a segment of tig1361. I also need to invert the whole thing
# tig1361 should also be inverted
# segments:
# X:50589701-167517504, -, tig00001361:8222080-15875483, -, X:1-42423604, -
samtools faidx ../ARS-UCD1.0.7.fa X:50589701-167517504 > chrx_seg1.fa
samtools faidx ../../rdcheck/canu_tigs_1238_9294_1361_1577.fa tig00001361:8222080-15875483 > chrx_seg2.fa
samtools faidx ../ARS-UCD1.0.7.fa X:1-42423604 > chrx_seg3.fa

~/jdk1.8.0_05/bin/java -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chrx.order.list -o version_8_fixed_chrx.fa -p 100
ls version_8_fixed_chrx.fa > correction_fastas.v8.list
# Whoops! I may have accidentally left out the previous corrections! Making sure that these corrections have been incorporated
ls ../ver_7_corrections/version_7_fixed_chr2*.fa >> correction_fastas.v8.list

# I need to get rid of the module loading for each system command if the module isn't available!
cp ../reorder_fasta.pl ./reorder_fasta_noslurm.pl
vim ./reorder_fasta_noslurm.pl
perl ./reorder_fasta_noslurm.pl ../ARS-UCD1.0.8.fa ../ARS-UCD1.0.7.fa correction_fastas.v8.list
```

<a name="nine"></a>
## ARS-UCD version 1.0.9

This is the final step, where we remove the last portion of the PAR X that was mistakenly placed on chr12.

> assembler2: /mnt/nfs/nfs2/dbickhart/dominette_asm/chr_fixing/ver_9_corrections

```bash
# OK I just need to remove a section of chr12 and stitch the chromosome back together
# Segments:
# chr12:1-71027332:+, chr12:71703378-87827655
samtools faidx ../ARS-UCD1.0.8.fa 12:1-71027332 > chr12_seg1.fa
samtools faidx ../ARS-UCD1.0.8.fa 12:71703378-87827655 > chr12_seg2.fa

ls *.fa > chr12_order.list
module load java/jdk1.8.0_92
sbatch --mem=15000 --nodes=1 --ntasks-per-node=4 --wrap="java -Xmx15g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr12_order.list -o version_9_fixed_chr12.fa -p 100"

ls version_9_fixed_chr12.fa > correction_fastas.v9.list
sbatch ../reorder_fasta.pl ../ARS-UCD1.0.9.fa ../ARS-UCD1.0.8.fa correction_fastas.v9.list
sbatch --dependency=afterok:678828 --nodes=1 --mem=5000 --ntasks-per-node=1 --wrap="samtools faidx ../ARS-UCD1.0.9.fa; gzip ../ARS-UCD1.0.9.fa;"
```

#### Restart and final assembly

We need to make a big decision about the X chromosome. I'm going to gather some stats to see how we should place the contig_x_unplaced and other factors.

> fry: /mnt/nfs/nfs2/dbickhart/dominette_asm/chr_fixing

```bash
mkdir nucmer_v6
cd nucmer_v6/
samtools faidx ../ARS-UCD1.0.6.fa X > v6_chrX.fa
for i in `perl -lane 'if(length($F[0]) <=2){next;}else{print $F[0];}' < ../ARS-UCD1.0.6.fa.fai`; do samtools faidx ../ARS-UCD1.0.6.fa $i >> v6_unplaced.fa; done

# OK, I need to grep out the unique portion of contig_X_unplaced first
# I am going to identify the location based on my nucmer alignments
grep 'contig_X' ../nucmer_v6/v6_unplaced.dna.mcoords
	6843956 6847028 5584488 5587541 3073    3054    98.99   167517504       8532179 0.00    0.04    X       contig_X_unplaced
	6858730 6897501 6536498 6575266 38772   38769   99.93   167517504       8532179 0.02    0.45    X       contig_X_unplaced

# so the biggest gap is located here: 5587541-6536498
samtools faidx ../ARS-UCD1.0.6.fa contig_X_unplaced:5587541-6536498 > contig_X_unplaced_trimmed.fa

ls version_7_fixed_chr2*.fa > correction_fastas_v7.list
# I added all of the "alt_contig" and "alt_X" entries from Bob's list to the final correction document
perl -lane 'if(!defined($F[1])){print "$_\tremove";}else{print $_;}' < correction_fastas_v7.list > temp
mv temp correction_fastas_v7.list
sbatch ../reorder_fasta.pl ../ARS-UCD1.0.7.fa ../ARS-UCD1.0.6.fa correction_fastas_v7.list
sbatch --dependency=afterok:676815 --nodes=1 --mem=4000 --ntasks-per-node=1 --wrap="samtools faidx ../ARS-UCD1.0.7.fa; gzip ../ARS-UCD1.0.7.fa"
```

<a name="polish"></a>
## Polishing the assembly

OK, I am going to run the Pilon and QC steps of the final assembly. First, let's get everything ready.

> assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_110

```bash
sbatch --nodes=1 --ntasks-per-node=1 --mem=10000 --wrap="module load bwa; bwa index ARS-UCD1.0.10.fasta"

# OOPs! I need to get the SRA fastq files ready for alignment!
for i in `ls /mnt/nfs/nfs2/SequenceData/Dominette/dominette_ilmn/*.sra`; do echo $i; sbatch --nodes=1 --ntasks-per-node=1 --mem=5000 --wrap="fastq-dump -O dominette_fastqs --split-files $i"; done

# Checking recmap coords
sbatch --nodes=1 --mem=10000 --ntasks-per-node=2 --wrap="perl /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a ARS-UCD1.0.10.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest.fa -o ars_ucd_v110_recmap"
# Also for the v9 assembly
sbatch --nodes=1 --mem=10000 --ntasks-per-node=2 --wrap="perl /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a /mnt/nfs/nfs2/dbickhart/dominette_asm/chr_fixing/ARS-UCD1.0.9.fa -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest.fa -o ars_ucd_v110_recmap"

# Aligning hiseq data to check read depth coverage
perl ~/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl -b aligns -t dominette_fastqs/dominette_fastq_list.tab -f ARS-UCD1.0.10.fasta -m

# While I wait for all of this, and to confirm most of what I've already seen, let's start running nucmer plots
for i in 1a `seq 2 29` X; do echo $i; ver9=nucmer/ars_v9_${i}.fa; ver10=nucmer/ars_v10_${i}.fa; sbatch --nodes=1 --ntasks-per-node=1 --mem=5000 --wrap="samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/chr_fixing/ARS-UCD1.0.9.fa $i > $ver9; samtools faidx ARS-UCD1.0.10.fasta $i > $ver10"; done
for i in 1a `seq 2 29` X; do echo $i; ver9=ars_v9_${i}.fa; ver10=ars_v10_${i}.fa; sbatch /mnt/nfs/nfs2/bickhart-users/binaries/run_nucmer_plot_automation_script.sh $ver9 $ver10; done

sbatch --nodes=1 --mem=10000 --ntasks-per-node=1 --wrap="module load samtools; samtools index ars_110_dominette_aligns.bam"
sbatch --dependency=afterok:679103 /mnt/nfs/nfs2/dbickhart/dominette_asm/chr_fixing/generate_coverage_bed.sh ars_110_dominette_aligns.bam ../../ARS-UCD1.0.10.fasta

# Now to test the regions
sbatch --mem=20000 --nodes=1 --ntasks-per-node=2 --wrap="java -Xmx20g -jar /mnt/nfs/nfs2/bickhart-users/binaries/GetMaskBedFasta/store/GetMaskBedFasta.jar -f ARS-UCD1.0.10.fasta -o ARS-UCD1.0.10.gaps.bed -s ARS-UCD1.0.10.gaps.stats"
sbatch convert_mcoords_to_cov_gaps.pl -m ../../nucmer/ars_v10_X.dna.mcoords -g ars_v10_v9_cov_gaps.bed -t 500

# Zero coverage regions, without gaps, that are present only in ARS-UCD version 1.0.10
intersectBed -a ars_v10_v9_cov_gaps.bed -b ../../ARS-UCD1.0.10.gaps.bed -v | intersectBed -a stdin -b ars_110_dominette_aligns.bam.zcov.merged.bed | perl -lane '$diff = $F[2] - $F[1]; print "$F[0]\t$F[1]\t$F[2]\t$diff";' | perl -e '$c = 0; while(<>){chomp; @s = split(/\t/); $c += $s[3];}print "$c\n";'
74,690

# It checks out, I think. Time to start polishing
```

Note: ARS-UCD1.0.11.s.fasta is the version of the 11 assembly that Serge generated through Arrow. The base fasta was prepared using the fastq file to extract the fasta sequence.

> assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_111

```bash
sbatch --nodes=1 --mem=10000 --ntasks-per-node=1 --wrap="module load bwa; bwa index ARS-UCD1.0.11.fasta"

perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl  -b polish -t polishing_dominette_illumina.tab -f ARS-UCD1.0.11.fasta -m

# Ack! All of the NextSeq files failed midway through because of read pair synchronization issues!
# While I try to reprocess the NextSeq files, I'm going to run the SRA data files as well.

perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl  -b altalign -t altalign_dominette_illumina.tab -f ARS-UCD1.0.11.fasta -m

# Test run of a new java program to try to reconcile the fastq files
sbatch --nodes=1 --ntasks-per-node=4 --mem=20000 --wrap="module load java/jdk1.8.0_121; java -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar pair -f /mnt/nfs/nfs2/brosen/projects/ARS-UCD/Dominette_NextSeq_data/LIB18483_S1_L001_R1_001.fastq -r /mnt/nfs/nfs2/brosen/projects/ARS-UCD/Dominette_NextSeq_data/LIB18483_S1_L001_R2_001.fastq -o dominette_fastqs/LIB18483_S1_L001_001"

```

#### Pilon run

I now need to run Pilon on the aligned data. Given the directory structure of the cluster, I want to test this out first to see how everything works.

> assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_111

```bash
mkdir pilon
# Testing the first contig in the fasta index file
sbatch --nodes=1 --ntasks-per-node=2 --mem=3500 --wrap="java -Xmx3g -jar /opt/agil_cluster/pilon/1.22/pilon-1.22.jar --frags altalign/dominette/dominette.sorted.merged.bam --frags nextseq/dominette/dominette.sorted.merged.bam --outdir pilon --output Leftover_ScbfJmS_660_Leftover_ScbfJmS_322 --vcfqe --diploid --fix bases --targets Leftover_ScbfJmS_660_Leftover_ScbfJmS_322 --genome ARS-UCD1.0.11.fasta"

#NOTE: the program will eat up as much memory as I can give it, so it crashes without proper memory support
perl runPilonErrorCorrection.pl ARS-UCD1.0.11.fasta /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_111/altalign/dominette/dominette.sorted.merged.bam /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_111/nextseq/dominette/dominette.sorted.merged.bam

# Damn, some of the higher memory tasks were unable to be queued!
# Queueing the high mem jobs on the assemblers
for i in 1a 2 3 4 5 6; do sbatch -o pilon/outLog/${i}.out -e pilon/errLog/${i}.err --nodes=1 --ntasks-per-node=2 --mem=168000 -p assemble2 --wrap="module load java/jdk1.8.0_131; java -Xmx166g -jar /opt/agil_cluster/pilon/1.22/pilon-1.22.jar --frags altalign/dominette/dominette.sorted.merged.bam --frags nextseq/dominette/dominette.sorted.merged.bam --outdir pilon --output ${i} --vcfqe --diploid --fix bases --targets ${i} --genome ARS-UCD1.0.11.fasta"; done

for i in X 7 8 9 10 11; do sbatch -o pilon/outLog/${i}.out -e pilon/errLog/${i}.err --nodes=1 --ntasks-per-node=2 --mem=168000 -p assemble3 --wrap="module load java/jdk1.8.0_131; java -Xmx166g -jar /opt/agil_cluster/pilon/1.22/pilon-1.22.jar --frags altalign/dominette/dominette.sorted.merged.bam --frags nextseq/dominette/dominette.sorted.merged.bam --outdir pilon --output ${i} --vcfqe --diploid --fix bases --targets ${i} --genome ARS-UCD1.0.11.fasta"; done

# Now for the remaining, smaller jobs
perl -lane 'if(! -e "pilon/$F[0].fasta"){print $F[0];}' < ARS-UCD1.0.11.fasta.fai | grep -P '^[LS]' > remaining_to_be_polished.list

for i in `cat remaining_to_be_polished.list`; do sbatch -o pilon/outLog/${i}.out -e pilon/errLog/${i}.err --nodes=1 --ntasks-per-node=2 --mem=8500 --wrap="module load java/jdk1.8.0_131; java -Xmx8g -jar /opt/agil_cluster/pilon/1.22/pilon-1.22.jar --frags altalign/dominette/dominette.sorted.merged.bam --frags nextseq/dominette/dominette.sorted.merged.bam --outdir pilon --output ${i} --vcfqe --diploid --fix bases --targets ${i} --genome ARS-UCD1.0.11.fasta"; done

# and to summarize the corrections made:
perl condense_pilon_output_script.pl pilon/outLog/ > current_pilon_summary_stats.tab

# I need to polish contig_x_unplaced now
# Changing the name to contig_X_unplaced
samtools faidx ARS-UCD1.0.11.fasta contig_X_unplaced:5587541-6536498 > contig_x_unplaced_pilon/contig_x_unplaced.fa

samtools view -h altalign/dominette/dominette.sorted.merged.bam contig_X_unplaced:5587541-6536498:1-978860 | perl -ne '$_ =~ s/contig_X_unplaced:5587541-6536498/contig_X_unplaced/g; print $_;' | samtools view -bS -o contig_x_unplaced_pilon/altalign.contigxunplaced.bam -
samtools index contig_x_unplaced_pilon/altalign.contigxunplaced.bam

samtools view -h nextseq/dominette/dominette.sorted.merged.bam contig_X_unplaced:5587541-6536498:1-978860 | perl -ne '$_ =~ s/contig_X_unplaced:5587541-6536498/contig_X_unplaced/g; print $_;' | samtools view -bS -o contig_x_unplaced_pilon/nextseq.contigxunplaced.bam -
samtools index contig_x_unplaced_pilon/nextseq.contigxunplaced.bam

sbatch --mem=10000 --nodes=1 --ntasks-per-node=1 --wrap="bwa index contig_x_unplaced_pilon/contig_x_unplaced.fa"
samtools faidx contig_x_unplaced_pilon/contig_x_unplaced.fa

# The slurm queue was acting up, so I had to use this unqueued script
module load java/jdk1.8.0_131; java -Xmx19g -jar /opt/agil_cluster/pilon/1.22/pilon-1.22.jar --frags contig_x_unplaced_pilon/altalign.contigxunplaced.bam --frags contig_x_unplaced_pilon/nextseq.contigxunplaced.bam --outdir contig_x_unplaced --output contig_x_unplaced.pilon --vcfqe --diploid --fix bases --targets contig_X_unplaced --genome contig_x_unplaced_pilon/contig_x_unplaced.fa
Pilon version 1.22 Wed Mar 15 16:38:30 2017 -0400
Genome: contig_x_unplaced_pilon/contig_x_unplaced.fa
Target: contig_X_unplaced:1-978860
Fixing snps, indels
Input genome size: 978860
Processing contig_X_unplaced:1-978860
frags contig_x_unplaced_pilon/nextseq.contigxunplaced.bam: coverage 167
frags contig_x_unplaced_pilon/altalign.contigxunplaced.bam: coverage 31
Total Reads: 1667864, Coverage: 198, minDepth: 20
Confirmed 952894 of 978860 bases (97.35%)
Corrected 88 snps; corrected 56 small insertions totaling 81 bases, 20 small deletions totaling 37 bases
Large collapsed region: contig_X_unplaced:305711-354116 size 48406
Large collapsed region: contig_X_unplaced:386244-407347 size 21104
Large collapsed region: contig_X_unplaced:623130-651978 size 28849
Large collapsed region: contig_X_unplaced:657173-724539 size 67367
Large collapsed region: contig_X_unplaced:726565-743257 size 16693
Large collapsed region: contig_X_unplaced:868649-920969 size 52321
Large collapsed region: contig_X_unplaced:923600-972500 size 48901
contig_X_unplaced:1-978860 log:
Finished processing contig_X_unplaced:1-978860
Writing updated contig_X_unplaced_pilon to contig_x_unplaced/contig_x_unplaced.pilon.fasta
Mean frags coverage: 198
Mean total coverage: 198

# Now that it's all fixed, time to order and orient it
ls /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_111/pilon/*.fasta | sort | perl -lane 'print "$F[0]\t+";' > pilon_fasta_list.tab
echo -e "/mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_111/contig_x_unplaced/contig_x_unplaced.pilon.fasta\t+" >> pilon_fasta_list.tab

perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_pipeline/generateAlignSlurmScripts.pl  -b align -t next_seq_files_validation.tab -f ARS-UCD1.0.12.fasta.gz -m

sbatch /mnt/nfs/nfs2/dbickhart/dominette_asm/serge_script_oneshot.sh align/dominette/dominette.sorted.merged ARS-UCD1.0.12.fasta dominette
/mnt/nfs/nfs2/dbickhart/dominette_asm/vcfToBedpe -i align/dominette/dominette.sorted.merged.lumpy.vcf -o align/dominette/dominette.sorted.merged.lumpy.bedpe

perl ../../bickhart-users/binaries/GoatAssemblyScripts/assembly_frc_benchmarking/summarizeAnalysisSlurm.pl -b run1only/canu/dominette/dominette.sorted.merged,run1only/ctx/dominette/dominette.sorted.merged,run1only/polished/dominette/dominette.sorted.merged,run1only/polished.final/dominette/dominette.sorted.merged,run1only/topolish.no1b/dominette/dominette.sorted.merged,run1only/umd3/dominette/dominette.sorted.merged,/mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_112/align/dominette/dominette.sorted.merged -n canu,ctx,polished,polished.final,topolish.no1b,umd3,ver12 -o cattle_asms_summary_stats_v12.md
```

<a name="thirteen"></a>
#### v1.0.13

This is likely to be the final version. The changes list is very small and constitutes only one removal, one inversion and one new contig inclusion. Since few bases are being altered, we will likely not polish this version of the assembly.

Changes:
* Invert chr10 telomere
* Remove mtDNA hit on chrX
* Add new mtDNA contig
* Identify and mask stretches of bases less than 5bp long
* Rebuild fasta using individual contig fasta files

> assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_113

```bash
# Identifying short stretches of bases
# there's only the one: 
# 26:23086082-23086085

# chr10
# This is just an inversion of the region identified by Serge
# His last alignment corresponds with a large gap at the end of the chromosome, so I will break at the beginning of the gap and reorder the segment with 100bp gap padding (instead of the original 5kb gap!)
# Order:
# 10:1-102170177:+ , 10:102175176-103157611:-
mkdir v12_segments
mkdir v12_final_contigs
samtools faidx ../ars_ucd_112/ARS-UCD1.0.12.fasta 10:1-102170177 > v12_segments/chr10_seg1.fa
samtools faidx ../ars_ucd_112/ARS-UCD1.0.12.fasta 10:102175176-103157611 > v12_segments/chr10_seg2.fa

vim chr10_order.list
java -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr10_order.list -o v12_final_contigs/10.fasta -p 100
vim v12_final_contigs/10.fasta # To remove the "merged" fasta head

# chrX
# I need to convert Serge's v11 X coords to v12 first
# v11 coords: X:38890116-38903460
samtools faidx ../ars_ucd_111/ARS-UCD1.0.11.fasta X:38890116-38903460 > mt_mapping_coords.fa
cat cow.mit.fasta >> mt_mapping_coords.fa
sbatch --nodes=1 --mem=6000 --ntasks-per-node=1 --wrap="module load bwa; bwa mem ../ars_ucd_112/ARS-UCD1.0.12.fasta mt_mapping_coords.fa > mt_mapping_coords.sam"
perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_scripts/BriefSamOutFormat.pl -s mt_mapping_coords.sam

# It looks like the mtDNA coords and the region of the X match up with the following area: X:38890932-38904279
# However, there's a small portion at the end of the mt contig that is skewed towards the front: X:38887938-38890932
# I'm going to strip all matching coordinates

# Order:
# X:1-38887938:+, X:38904279-167334494:+
samtools faidx ../ars_ucd_112/ARS-UCD1.0.12.fasta X:1-38887938 > v12_segments/chrX_seg1.fa
samtools faidx ../ars_ucd_112/ARS-UCD1.0.12.fasta X:38904279-167334494 > v12_segments/chrX_seg2.fa

vim chrX_order.list
java -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chrX_order.list -o v12_final_contigs/X.fasta -p 100

# OK, now to build the final fasta:
for i in 1 2 3 4 5 6 7 8 9; do echo $i; samtools faidx ../ars_ucd_112/ARS-UCD1.0.12.fasta $i >> ARS-UCD1.0.13.fasta; done
cat v12_final_contigs/10.fasta >> ARS-UCD1.0.13.fasta
for i in `seq 11 29`; do echo $i; samtools faidx ../ars_ucd_112/ARS-UCD1.0.12.fasta $i >> ARS-UCD1.0.13.fasta; done
cat v12_final_contigs/X.fasta >> ARS-UCD1.0.13.fasta
cat cow.mit.fasta >> ARS-UCD1.0.13.fasta
sort -k1 ../ars_ucd_112/ARS-UCD1.0.12.fasta.fai | perl -lane 'if($F[0] =~ /^\d/ || $F[0] =~ /^X/){next;} if($F[2] == -1){open(IN, "samtools faidx ../ars_ucd_111/pilon/$F[0].fasta $F[0]_pilon |"); while(<IN>){chomp; $_ =~ s/_pilon//g; print "$_";} close IN; }else{system("samtools faidx ../ars_ucd_112/ARS-UCD1.0.12.fasta $F[0]");}' >> ARS-UCD1.0.13.fasta

# I need to remove that one solitary base
vim lone_g_base.bed
maskFastaFromBed -fi ARS-UCD1.0.13.fasta -bed lone_g_base.bed -fo temp_masked.fa
java -jar /mnt/nfs/nfs2/bickhart-users/binaries/GetMaskBedFasta/store/GetMaskBedFasta.jar -f temp_masked.fa -o temp_masked.gaps.bed -s temp_masked.gaps.stats
mv temp_masked.fa ARS-UCD1.0.13.fasta

# Compressing
sbatch --nodes=1 --ntasks-per-node=8 --mem=10000 --wrap="md5sum ARS-UCD1.0.13.fasta > ARS-UCD1.0.13.md5; pigz ARS-UCD1.0.13.fasta"
```

Summary:
* chr10 telomeric region (10:102175176-103157611) inverted
* chrX regions matching mtDNA contig removed X:38887938-38904279
* mtDNA contig added
* The single "g" nucleotide on chr26 was masked (26:23086082-23086085)
* 37 leftover contigs added back into v13 from their absence in v12 (unintended)

#### Confirming polished assembly

```bash
sbatch /mnt/nfs/nfs2/dbickhart/dominette_asm/serge_script_oneshot.sh align/dominette/dominette.sorted.merged ARS-UCD1.0.13.fasta dominette
cd /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_113/align/dominette/
/mnt/nfs/nfs2/dbickhart/dominette_asm/vcfToBedpe -i dominette.sorted.merged.lumpy.vcf -o dominette.sorted.merged.lumpy.bedpe

cd /mnt/nfs/nfs2/dbickhart/dominette_asm/
perl ../../bickhart-users/binaries/GoatAssemblyScripts/assembly_frc_benchmarking/summarizeAnalysisSlurm.pl -b run1only/topolish.no1b/dominette/dominette.sorted.merged,run1only/umd3/dominette/dominette.sorted.merged,/mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_112/align/dominette/dominette.sorted.merged,/mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_113/align/dominette/dominette.sorted.merged -n topolish.no1b,umd3,ver12,ver13 -o cattle_asms_summary_stats_v13.md

cd /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_113/align/dominette/

# More BND than expected. Going to check on them
grep 'SVTYPE=BND' dominette.sorted.merged.lumpy.bedpe | perl -lane 'print "$F[0];$F[3]";' | perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 0 > v13_bnd_trans_counts.tab
grep 'SVTYPE=BND' ../../../ars_ucd_112/align/dominette/dominette.sorted.merged.lumpy.bedpe | perl -lane 'print "$F[0];$F[3]";' | perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 0 > v12_bnd_trans_counts.tab

diff v13_bnd_trans_counts.tab v12_bnd_trans_counts.tab

# The differences look really random. Testing a few contigs out for sequence similarity
samtools faidx ../../ARS-UCD1.0.13.fasta Leftover_ScbfJmS_2140 > v13_scbfjms_2140.fa
samtools faidx ../../../ars_ucd_112/ARS-UCD1.0.12.fasta Leftover_ScbfJmS_2140 > v12_scbfjms_2140.fa
diff v13_scbfjms_2140.fa v12_scbfjms_2140.fa



```

<a name="snps"></a>
## SNP remapping and stats

These are my notes on the remapping of SNP probes from the HD array to the new assembly. I have two main goals here:

* Generate a SNP location list for Paul and John to check
* Determine how many SNP locations have moved from UMD3



> 3850: /home/bickhart
```bash
perl -e 'for($x = 0; $x < 6; $x++){<>;} while(<>){chomp; if($_ =~ /^#/){next;} @s = split(/,/); @b = split(/[\[\]]/, $s[6]); $b[2] =~ tr/ACGT/TGCA/; $b[2] = reverse($b[2]); print ">$s[1].f\n$b[0]\n>$s[1].r\n$b[2]\n";} close IN;' < /work1/grw/chips/GH2/GGP_HDv2_B_StrandReport_FDT_V1.csv > ggp_probe_design.fa

perl -e 'open(O1, "> ggp_probe_design.1.fa"); open(O2, "> ggp_probe_design.2.fa"); while($n1 = <>){ $s1 = <>; $n2 = <>; $s2 = <>; $n1 =~ s/.f//; $n2 =~ s/.r//; print O1 "$n1$s1"; print O2 "$n2$s2"; }' < ggp_probe_design.fa
```

> pwd: /home/dbickhart/share/btau4_data

```bash
# I converted the BovineHD data into single line fasta entries.
```

Now to align the data to the polished assembly and generate some stats.

> Assembler2: /mnt/nfs/nfs2/dbickhart/dominette_asm/snps/

```bash
# HD probes
sbatch --nodes=1 --mem=8000 --ntasks-per-node=1 --wrap="module load bwa; bwa mem /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_113/ARS-UCDv1.0.13.fa BovineHD_B1.probeseq.fa > BovineHD_B1.probes.ars_ucdv13.sam"

# GGP probes
sbatch --nodes=1 --mem=8000 --ntasks-per-node=1 --wrap="module load bwa; bwa mem /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_113/ARS-UCDv1.0.13.fa ggp_probe_design.1.fa ggp_probe_design.2.fa > ggp_probes.ars_ucdv13.sam"

# OK, let's count some stats on the HD first
## HD data
# Samflags:
perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_scripts/BriefSamOutFormat.pl -s BovineHD_B1.probes.ars_ucdv13.sam | perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 1
Entry   Count
0       387439
16      387103
4       3420		<- unmapped

# Align length
perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_scripts/BriefSamOutFormat.pl -s BovineHD_B1.probes.ars_ucdv13.sam | perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 5
Entry   Count
50      777962

# Chromosome count
perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_scripts/BriefSamOutFormat.pl -s BovineHD_B1.probes.ars_ucdv13.sam | perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 2 > BovineHD_B1.chr_snp_count.tab

# OK, pretty easy to format
perl /mnt/nfs/nfs2/bickhart-users/binaries/perl_toolchain/sequence_data_scripts/BriefSamOutFormat.pl -s BovineHD_B1.probes.ars_ucdv13.sam | perl -lane '$s = 0; if($F[1] == 4){$s = -1;}elsif($F[1] == 16){$s = $F[3] - 1;}else{$s = $F[4] + 1;} print "$F[0]\t$F[2]\t$s";' > BovineHD_B1.snplocations.tab

```

## QC master table

|Category         |canu  | ctx  | polished | polished.final | topolish.no1b | umd3 | ver12 | ver13 |
|:----------------|:----------------|:----------------|:----------------|:----------------|:----------------|:----------------|:----------------|:---|
|BND              |  3157|   842|  4077|  3298|  2681| 13258|  2382|  2388|
|COMPR_PE         | 13937| 17704| 28604| 24878| 14454| 22221|  7322|  7342|
|DEL              |  1593|  1348|  2159|  2013|  1491| 12069|  1084|  1083|
|DUP              |   450|   458|  1120|  1202|   439|  3222|   354|   353|
|HIGH_COV_PE      |  7419|  7498|  9743|  9844|  7234|  6605|  7778|  7858|
|HIGH_NORM_COV_PE |  5567|  5573|  7581|  7656|  5464|  5849|  6092|  6116|
|HIGH_OUTIE_PE    |    85|    41|    80|    95|    90|  2280|   106|   105|
|HIGH_SINGLE_PE   |   191|   242|   234|   253|    83|  1289|    80|    80|
|HIGH_SPAN_PE     |  9926|  9480| 13695| 13784|  4986|  3959|  4765|  4815|
|INV              |    85|    83|   110|    99|    73|  2157|    67|    67|
|LOW_COV_PE       | 42779| 36226| 75878| 76200| 55912| 50934| 55655| 55733|
|LOW_NORM_COV_PE  | 41385| 34820| 82166| 82693| 55203| 55638| 53091| 53188|
|QV               |    41|    41|    40|    40|    41|    41|    40|    40|
|STRECH_PE        | 27257| 25495| 26656| 25697| 27470| 28936| 18861| 18897|

<a name="problems"></a>
## Problems with assembly 

Bob found some regions of UMD3 that are apparently not present in the ARS-UCD assembly. Checking them now.

> assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_114_igc/ars_ucd_14_igc_rmask

```bash
module load bedtools/2.26.0
grep 'chain' combined_chain/chr6.chain | perl -lane 'if($F[6] >= 1445418 && $F[5] <= 3818492){print "$F[2]\t$F[5]\t$F[6]\t$F[4]\t$F[7]\t$F[10]\t$F[11]\t$F[9]\t$F[12]";}' | sortBed -i stdin > umd_6_1445418_3818492_mappings.bed

# Writing a script to automate this
perl check_coordinates.pl combined_chain/chr6.chain 5221411 6782370 umd_6_5221411_6782370_mappings.bed
for i in "20:25315005-25372272" "21:33417070-33470664" "21:55762119-55792041" "21:59812700-60709528"; do chr=`echo $i | cut -d':' -f1`; start=`echo $i | cut -d':' -f2 | cut -d'-' -f1`; end=`echo $i | cut -d':' -f2 | cut -d'-' -f2`; echo $start $end $chr; perl check_coordinates.pl combined_chain/chr${chr}.chain $start $end umd_${chr}_${start}_${end}_mappings.bed; done

head -n 99 *_mappings.bed
```

And the script I wrote:

#### check_coordinates.pl

```perl
#!/usr/bin/perl
# A formalized script to wrap this shell command:
# grep 'chain' combined_chain/chr6.chain | perl -lane 'if($F[6] >= 1445418 && $F[5] <= 3818492){print "$F[2]\t$F[5]\t$F[6]\t$F[4]\t$F[7]\t$F[10]\t$F[11]\t$F[9]\t$F[12]";}' | sortBed -i stdin

use strict;

chomp(@ARGV);
my $usage = "A utility to check blat alignments from one chr to another\nperl $0 <chain file> <start coord> <end coord> <output file>\n";

unless(scalar(@ARGV) == 4){
        print $usage;
        exit;
}

open(my $IN, "grep 'chain' $ARGV[0] |") || die "Could not open chain file!\n$usage";
open(my $OUT, "> temp");
while(my $line = <$IN>){
        chomp $line;
        my @F = split(/\s+/, $line);
        if($F[6] >= $ARGV[1] && $F[5] <= $ARGV[2]){
                print {$OUT} "$F[2]\t$F[5]\t$F[6]\t$F[4]\t$F[7]\t$F[10]\t$F[11]\t$F[9]\t$F[12]\n";
        }
}
close $IN;
close $OUT;

system("module load bedtools/2.26.0; cat temp | sortBed -i stdin > $ARGV[3]");
system("rm temp");
```

<a name="error_correction"></a>
## Large scale assembly error correction

Bob found about 2 megabases of sequence that was chopped after we attempted to correct the ARSv1 assemblies. He discovered this during the HD probe realingments, but much of the problem was due to our use of the recmap to place segments. The recmap and linkage maps had large gaps that precluded accurate slicing of the chromosomes. These are some notes to try to reconcile discarded segments from the assembly.

#### Region 11 (Leftover_ScbfJmS_1962)

This region appears to be a floating remnant of a portion of the true chromosome 6 segment on the old "topolish" assembly. It is the majority of the missing sequence, and apparently portions of it were sliced off into a leftover contig when the assemblies were reconciled. Let's see if we can't pull discordant reads from the region of chr6 that corresponds to this alignment. From Ben's alignments, the ARS-UCDv14 assembly ends at 6:1290324-1307562

> Assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_114_igc/targeted_error

```bash
# First, let's assess read depth in the region for a real animal
perl -e 'for($x = 1280324; $x < 1317562; $x += 1000){$e = $x + 1000; print "6\t$x\t$e\n";}' > region11_ars14_depth_coords.bed

samtools view -h /mnt/nfs/nfs1/derek.bickhart/CDDR-Project/aligns/001HO05072/001HO05072.sorted.merged.bam 6:1280324-1318562 |  samtools depth -b region11_ars14_depth_coords.bed - > region11_ars14_depth_coords.counts.bed
```

```R
data <- read.delim("region11_ars14_depth_coords.counts.bed", header=FALSE)
pdf(file="arsv14_chr6_region11_depth.pdf", useDingbats=FALSE)
plot(as.numeric(data$V2), as.numeric(data$V3))
dev.off()
```
There's definitely a lot of read depth dropoff in the area and it's highly repetitive. Let's see if we can extract read pairs that map to two separate chromosomes.

```bash
sbatch --nodes=1 --ntasks-per-node=1 --mem=10000 --wrap="samtools view /mnt/nfs/nfs1/derek.bickhart/CDDR-Project/aligns/001HO05072/001HO05072.sorted.merged.bam 6:1280324-1318562 > region11_001HO05072_mappedreads.sam"

wc -l region11_001HO05072_mappedreads.sam
4093 region11_001HO05072_mappedreads.sam

perl ~/sperl/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f region11_001HO05072_mappedreads.sam -c 6
# The majority mapped to chr6, and no mappings to ScbfJmS_1962 as Bob had found. 19 mapped to chr2 and 16 to chr4
samtools view /mnt/nfs/nfs1/derek.bickhart/CDDR-Project/aligns/001HO05072/001HO05072.sorted.merged.bam Leftover_ScbfJmS_1962 | perl ~/sperl/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -c 6 -f stdin

# Only one read to chr6 and again, the majority were to the same contig
ST-E00268:255:HGKYNALXX:5:2124:19989:22053      129     Leftover_ScbfJmS_1962   5088    60      151M    6       61579908        0       TTAATTTCATGGCTGCAGTCACCATCTGCAGTGATTTTGGAGCCCCCCAAAATAAAGTCTGCCACTGTTTCTCCATCTATTTGCCATGAAGTGATGGGATCAGATGCCATGATCTTAGTTTTCTGAGTGTTGAACTTTAAGCCAACTTTTA   AAFAFJJJJJJJJJJJJJJJJJJJJFJJJJJJJJJJJJJJJJJJJJJJJJJFJJJJJJJJJJJJJAJJJJJJJJ7FJJJJJJJJJFFJJJJFFJJJAFFJJJFAFJJJ<JJFFJJJJF-FAAJJJ-FAJJJJJAJJJAFAAF7FFAJFFF<     NM:i:0  MD:Z:151        AS:i:151        XS:i:116        RG:Z:001HO05072-lib1

# not even in the same ballpark, sadly. I'm going to have to use a different approach.
# IDEA: I will try to get nucmer alignments of the missing region (and flanking sites) and to get recmap coordinate mappings
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:18000094-20409546 > topolish.region11.chr6.fa
samtools faidx ../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6 > arsv14.region11.chr6.fa
sbatch ../../../binaries/run_nucmer_plot_automation_script.sh arsv14.region11.chr6.fa topolish.region11.chr6.fa

# Now, Bob had run the Dominette WGS reads on the Topolish assembly and then used my script to realign the one-end-mapped reads onto the v14 assembly
# I think that the alternative is what we need, so let's see if we can get better resolution here.
samtools view -h -f 8 -F 260 /mnt/nfs/nfs1/derek.bickhart/CDDR-Project/aligns/001HO05072/001HO05072.sorted.merged.bam 6:1280324-1318562 > arsv14.region11.001HO05072.oneendmapped.sam
samtools view -h -f 4 -F 264 /mnt/nfs/nfs1/derek.bickhart/CDDR-Project/aligns/001HO05072/001HO05072.sorted.merged.bam 6:1280324-1318562 > arsv14.region11.001HO05072.endunmapped.sam

samtools merge arsv14.region11.001HO05072.combo.bam arsv14.region11.001HO05072.oneendmapped.sam arsv14.region11.001HO05072.endunmapped.sam
samtools sort -n -T temp -o arsv14.region11.001HO05072.merged.rnsort.bam arsv14.region11.001HO05072.combo.bam

# Aligning to the alternative reference
perl ~/sperl/assembly_scripts/findUnmappedReadConsensus.pl -b arsv14.region11.001HO05072.merged.rnsort.bam -r /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa  -o arsv14.region11.001HO05072 -m 0 -t 8
# Even with no mapq filter, the only mapped segment is:
6       1307156 1307632 6       97883741        97884130

# Trying some other assemblies
perl ~/sperl/assembly_scripts/findUnmappedReadConsensus.pl -b arsv14.region11.001HO05072.merged.rnsort.bam -r /mnt/nfs/nfs2/dbickhart/dominette_asm/canu.mhap.all.fasta  -o canu.mhap.region11.001HO05072 -m 0 -t 8
```

<a name="recmap_rev"></a>
#### Recmap revision

I am now going to replicate some of what Bob found with the HD probeset just to get my bearings for extracting and realigning segments of the genome.

```bash
# First the HD probes
sbatch /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a ../ARS-UCD1.0.14.clean.wIGCHaps.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probeseq.fa -o arsv14.hdprobes
sbatch /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probeseq.fa -o topolish.hdprobes

# Now the recmap probes
sbatch /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest.fa -o topolish.recmap
sbatch /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a ../ARS-UCD1.0.14.clean.wIGCHaps.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest.fa -o arsv14.recmap

# 6       1431432; 6       3780334 # UMD3 recmap coordinates missing in ARSv14
# Pulling marker names from the missing locations
perl -lane 'if($F[4] == 6 && $F[5] <= 3780344 && $F[5] >= 1431432){print $F[0];}' < arsv14.recmap.tab > arsv14.recmap.missingmarkers.inregion.list

# Extracting marker locations from the topolish assembly
perl -e 'chomp(@ARGV); my %list; open($IN, "< $ARGV[0]"); while(<$IN>){chomp; $list{$_} = 1;} close $IN; open($IN, "< $ARGV[1]"); while(<$IN>){chomp; @s = split(/\t/); if(exists($list{$s[0]})){print join("\t", @s); print "\n";}} close $IN;' arsv14.recmap.missingmarkers.inregion.list topolish.recmap.tab

# OK, the recmap to the rescue! The surgery on this segment of 6 was difficult because it was segmented in several locations here. I made the mistake in v1.0.4 by chopping too much of the terminal ends of a segment here

#Upstream topolish marker maps 6       22253128; 6       22522377; 6       22536259 --- 6:22522377-22536259
#Downstream topolish marker maps 6       20315220; 6       20344150; 6       20415862 --- 6:20315220-20344150

# I'm now going to extract the consensus of those coordinates and walk the alignments of those sequence fragments to the ARS v14 assembly. The upstream marker coordinates will be the most difficult to reconcile because they're a segment break in the topolish assembly

samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:22522377-22536259 > topolish.region11.upstream.recmap.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:20315220-20344150 > topolish.region11.downstream.recmap.fa

perl ~/sperl/assembly_scripts/alignUnitigSectionsToRef.pl -f topolish.region11.upstream.recmap.fa -r ../ARS-UCD1.0.14.clean.wIGCHaps.fasta -o topolish.region11.upstream.recmap.tab
Longest aligments:      chr     start   end     length
                        6       2727712 2741595 13883

perl ~/sperl/assembly_scripts/alignUnitigSectionsToRef.pl -f topolish.region11.downstream.recmap.fa -r ../ARS-UCD1.0.14.clean.wIGCHaps.fasta -o topolish.region11.downstream.recmap.tab
Longest aligments:      chr     start   end     length
                        X       1971585 151276646       149305061
                        10      12132774        102258536       90125762
                        2       12075857        85391476        73315619
                        8       34649312        105871586       71222274
                        7       13560259        78424026        64863767
                        5       18284575        82234418        63949843
                        1       37754588        101121559       63366971
...

# So, it's actually the downstream that is the problem! I chopped the upstream correctly but the downstream is where the breakpoint diverges
# Let's reverse the coordinate maps
#6       1277739; 6       1326120
samtools faidx ../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6:1277739-1326120 > arsv14.region11.recmap.fa
perl ~/sperl/assembly_scripts/alignUnitigSectionsToRef.pl -f arsv14.region11.recmap.fa -r /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta -o arsv14.region11.downstream.recmap.tab
Longest aligments:      chr     start   end     length
                        1a      51484272        136621491       85137219
                        8       5148079 22867447        17719368
                        6       17994767        22257127        4262360
                        Leftover_ScbfJmS_1962   32      7038    7006
                        Leftover_ScbfJmS_1097   66889   66929   40

# Here are the relevant mappings from the tab file
6:1277739-1326120       0       2000    6       22253128        22255128        9;3
6:1277739-1326120       2000    3000    6       17994767        17995767        9
6:1277739-1326120       3000    4000    6       22256127        22257127        9
6:1277739-1326120       4000    5000    6       17996769        17997769        15
6:1277739-1326120       5000    6000    Leftover_ScbfJmS_1962   32      1032    9
6:1277739-1326120       6000    11000   6       17998768        18003772        60;60;59;60;16
6:1277739-1326120       11000   12000   Leftover_ScbfJmS_1962   6038    7038    23
6:1277739-1326120       12000   13000   6       18004772        18005772        18
6:1277739-1326120       12000   13000   6       20392406        20392749        18
6:1277739-1326120       12000   13000   Leftover_ScbfJmS_1097   66889   66929   0
6:1277739-1326120       13000   14000   8       5148117 5149117 2


# So it is clear that the breakpoint is in between the 12000-13000 bp range of the realignment (arsv14: 6:1289739-1290739)
# Testing one final breakpoint set from the topolish assembly
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:18005772-20392406 > topolish.region11.full.recmap.fa
perl ~/sperl/assembly_scripts/alignUnitigSectionsToRef.pl -f topolish.region11.full.recmap.fa -r ../ARS-UCD1.0.14.clean.wIGCHaps.fasta -o topolish.region11.full.recmap.tab
Longest aligments:      chr     start   end     length
                        X       217062  167058732       166841670
                        1       183355  157530446       157347091
                        2       516585  134762835       134246250
                        4       426310  119719020       119292710
                        5       114341  119377725       119263384
						...

# And the relevant segments:
6:18005772-20392406     0       12000   Leftover_ScbfJmS_1962   10171   1001    60;60;60;60;60;60;60;60;60;60;60;60;60
6:18005772-20392406     12000   14000   *       0       1000    0;0
6:18005772-20392406     14000   15000   19      25523766        25524766        0
...
6:18005772-20392406     2378000 2379000 12      1797669 1798669 0
6:18005772-20392406     2378000 2379000 2       10798739        10798795        0
6:18005772-20392406     2379000 2380000 7       61327529        61328529        6
6:18005772-20392406     2380000 2381000 X       10152536        10153536        1
6:18005772-20392406     2381000 2382000 18      62149239        62150239        13
6:18005772-20392406     2382000 2383000 6       1306751 1307751 60
6:18005772-20392406     2382000 2383000 5       113079404       113079495       0
6:18005772-20392406     2383000 2386634 6       1305752 1298200 60;60;9;0

# The coords at the end are inverted, going to try to get 8kb more resolution
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:20380406-20420406 > topolish.region11.fiveprime.recmap.fa
perl ~/sperl/assembly_scripts/alignUnitigSectionsToRef.pl -f topolish.region11.fiveprime.recmap.fa -r ../ARS-UCD1.0.14.clean.wIGCHaps.fasta -o topolish.region11.fiveprime.recmap.tab
Longest aligments:      chr     start   end     length
                        2       10798739        55511760        44713021
                        16      10957259        30852796        19895537
                        6       1306118 1330666 24548

# No additional resolution whatsover -- the alignment coordinates shifted, even!

# So here are my conclusions on the breakpoints:
# ARSv14: 6:1289739-1290739 <- cut segments with breakpoints flanking these coordinates
# Topolish: 6:18017772-20387406 <- add this segment in between the breakpoints and try to match the 5' end to the reference to avoid overlap.

# Let's try to get the finetuned overlap coords with nucmer
sbatch /mnt/nfs/nfs2/bickhart-users/binaries/run_nucmer_plot_automation_script.sh arsv14.region11.recmap.fa topolish.region11.fiveprime.recmap.fa
cat topolish.dna.mcoords
25389   29825   12006   7554    4437    4453    98.52   48382   40001   9.17    11.13   6:1277739-1326120       6:20380406-20420406
29824   48382   16904   35457   18559   18554   99.93   48382   40001   38.36   46.38   6:1277739-1326120       6:20380406-20420406

# Nucmer refined coordinates:
# ARSv14: 6:1289739-1303128		<- a potential loss of ~4kb
# Topolish: 6:18017772-20387960	<- a gain of 2.3 megs

# let's find the rest of chr6 that needs to be repaired
perl -lane 'if($F[4] == 6 && $F[1] eq "*"){print $F[0];}' < arsv14.recmap.tab > arsv14.recmap.missingmarkers.fullchr6.list
# removing the markers we just found a solution for:
perl ~/sperl/bed_cnv_fig_table_pipeline/nameListVennCount.pl -o arsv14.recmap.missingmarkers.fullchr6.list arsv14.recmap.missingmarkers.inregion.list
File Number 1: arsv14.recmap.missingmarkers.fullchr6.list
File Number 2: arsv14.recmap.missingmarkers.inregion.list
Set     Count
1       22
1;2     47
2       4	<- the mapped markers I used to orient myself near the region

mv group_1.txt arsv14.recmap.missingmarkers.remaining.chr6.list
perl -e 'chomp(@ARGV); my %list; open($IN, "< $ARGV[0]"); while(<$IN>){chomp; $list{$_} = 1;} close $IN; open($IN, "< $ARGV[1]"); while(<$IN>){chomp; @s = split(/\t/); if(exists($list{$s[0]})){print join("\t", @s); print "\n";}} close $IN;' arsv14.recmap.missingmarkers.remaining.chr6.list topolish.recmap.tab
Hapmap28104-BTA-156698  6       27888668        -       6       12261839	# single probe
BovineHD0600010244      6       16717302        -       6       36756588	# single probe
# problem region 1	solid block, also missing flanks in topolish
ARS-BFGL-NGS-35835      *       0       +       6       62788712
ARS-BFGL-NGS-1852       6       16611338        -       6       62834920
ARS-BFGL-NGS-109055     *       0       +       6       62933010
# problem region 2  overzealous cropping near rearrangement area
BovineHD0600029900      6       11497449        +       6       106463127	
ARS-BFGL-NGS-83571      6       5407789 +       6       106495683
ARS-BFGL-NGS-111057     6       5429230 -       6       106517122
ARS-BFGL-NGS-1012       6       5450170 +       6       106546711
BovineHD0600029934      6       5455590 +       6       106552130
ARS-BFGL-NGS-79719      6       5482388 +       6       106578932
BovineHD0600029951      6       5511199 -       6       106607689
# problem region 3  overzealous cropping, but complex
BTB-01699056    6       11581836        +       6       107394629 # this marker is probably fine
	# This is the marker where I made the original crop: BovineHD0600030299 6       11780742
ARS-BFGL-NGS-35366      6       6291894 +       6       107785745
BovineHD0600030375      6       6299963 +       6       107794033
# problem region 4 overzealous cropping again
ARS-BFGL-NGS-53620      6       7401935 -       6       109800337
ARS-BFGL-NGS-104207     6       7366692 -       6       109835444
ARS-BFGL-NGS-28132      6       11916710        -       6       109951981
ARS-BFGL-NGS-99549      6       11955725        -       6       109990555
# problem region 5 overzealous cropping again
BovineHD0600033290      6       631409  +       6       117005680
UA-IFASA-3742   6       635376  +       6       117106304
BovineHD0600033327      6       595885  +       6       117128088

# Let's make a script to automate the fasta chopping and reference alignment so that I'm not manually entering commands the whole time
# Running Regions 1, 2 and 5 as they fit into the automation script nicely
for i in "ARS-BFGL-NGS-35835:ARS-BFGL-NGS-109055" "BovineHD0600029900:BovineHD0600029951" "BovineHD0600033290:BovineHD0600033327"; do marker1=`echo $i | cut -d':' -f1`; marker2=`echo $i | cut -d':' -f2`; echo $marker1 $marker2; perl automate_region_slicing.pl 6 $marker1 $marker2 simple; done

# Only regions 2 and 5 had any reasonable coordinates from the automation
head simple_topolish_arsv14_BovineHD0600029900_BovineHD0600029951.align.tab
6:11454497-11497449     0       1000    6       101419997       101418042       60;60	<- the refined breakpoint coordinate is in this region on 6
6:11454497-11497449     1000    2000    4       112092009       112093009       8

# Damn, I just found out that this portion of chr6 needs to be resectioned anyways
# ARS-BFGL-NGS-113808     6       101417991
# seven recmap markers - region 2
# Hapmap46942-BTA-114876  6       110667049 - BTB-01544044    6       111564390
# 2 recmap markers - region 3
# BovineHD0600030391      6       111638810 - BTB-00283603    6       113452764
# four recmap markers - region 4
# ARS-BFGL-NGS-100510     6       101420998 - Hapmap31504-BTA-159055  6       108334009
# three recmap markers - region 5
# ARS-BFGL-NGS-106139     6       108475033 - BTA-77952-no-rs 6       110661272

# Welp, let's start placing segments! I want nucmer coords to try to separate out things
samtools faidx ../../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6:101417991-113452764 > arsv14_disjunction_2_3_4_5_regions.fa

# Because of the heterogeneity of the region in the ToPolish assembly, I need to grep out the segments individually
# Here are the segments from the recmap:
6       106495683       107259443       6       5407789 6158942 +       763760  751153	seg1
6       107394629       107585442       6       11581836        11780742        +       190813  198906	seg2
6       107678393       108677334       6       6337745 7287107 +       998941  949362	seg3
6       108756884       109835444       6       8476461 7366692 -       1078560 1109769	seg4 (-)
...
6       114590231       116931851       6       714275  3017439 +       2341620 2303164	seg5
6       117005680       117128088       6       631409  595885  -       122408  35524	seg6 (-)
	
# topolish segmentation
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:5407789-6158942 > segment1_topolish.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:11581836-11780742 > segment2_topolish.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:6337745-7287107 > segment3_topolish.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:7366692-8476461 > segment4_topolish.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:714275-3017439 > segment5_topolish.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:595885-631409 > segment6_topolish.fa

for i in segment*_topolish.fa; do sbatch ../../../../binaries/run_nucmer_plot_automation_script.sh arsv14_disjunction_2_3_4_5_regions.fa $i; done
# only segment 6 didn't align

# Segment1 coords:
perl -lane '$F[0] += 101417991; $F[1] += 101417991; $F[2] += 5407789; $F[3] += 5407789; print join("\t", @F);' < segment1_topolish.dna.mcoords
110659283       110661273       5520965 5522955 1991    1991    100.00  12034774        751154  0.02    0.27    6:101417991-113452764   6:5407789-6158942
# So the first portion of the alignment of topolish (1-113176 of segment1) didn't align to v14 which is almost the 172 kb Bob predicts is missing in his chunk 3.

# Segment2 coords:
head segment2_topolish.dna.mcoords
9889742 10074425        14216   198907  184684  184692  99.98   12034774        198907  1.53    92.85   6:101417991-113452764   6:11581836-11780742
# Only the first 14kb of this chunk belong to Bob's chunk4

# Segment3 coords:
# this aligned perfectly -- no change

# Segment4 coords:
#NOTE this is a wonderful inverted contig segment!
head segment4_topolish.dna.mcoords
...
11893994        12034774        258612  117777  140781  140836  99.94   12034774        1109770 1.17    12.69   6:101417991-113452764   6:7366692-8476461
# The first 117kb didn't align which is almost Bob's 136 kb in chunk 5

# Segment5 coords:
# This aligned just fine -- no change
```

<a name="nuccoord"></a>
#### nucmer coord strategy

Perhaps I'm going about this all wrong... it looks like v14 chr6 is ok on the coordinates apart from the translocation towards the end. Let's take the coordinates for both assemblies from nucmer, then find the missing portions, blast them against the recmap and pick up the pieces from there.

```bash
samtools faidx ../../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6 > arsv14_full_chr6.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6 > topolish_full_chr6.fa

sh ../../../../binaries/run_nucmer_plot_automation_script.sh arsv14_full_chr6.fa topolish_full_chr6.fa
# Going to pull out only the regions that had the largest unaligned portions
perl -e 'my @data; while(<>){chomp; @s = split(/\t/); push(@data, [$s[2], $s[3], $s[0], $s[1]]);} @data = sort{$a->[0] <=> $b->[0]} @data; for(my $x = 1; $x < scalar(@data); $x++){$len = $data[$x]->[0] - $data[$x - 1]->[1]; if(abs($len) > 100000){print $data[$x - 1]->[1] . "\t" . $data[$x]->[0] . "\t" . $data[$x]->[2] . "\t" . $data[$x]->[3] . "\t$len\n";}}' < topolish_full_chr6.dna.mcoords
# topolish side	v14 side					Bob's region matchups
5348369 5520964 110659282       110661272       172595		<- region 3
6163121 6337744 111499839       112449566       174623		<- region 4		
7288424 7625303 113311984       113511924       336879
7425340 7921167 113015980       113311881       495827
7625303 7998504 112938563       113015978       373201
7921093 8211911 112725163       112948557       290818
7988511 8214860 112722280       112725220       226349
8211909 8476467 112460345       112722927       264558		<- region 5 ballpark
8213895 8486231 112449572       112459341       272336		<- region 6 ballpark
11454547        11596051        111307732       111492416       141504	<- region 7 ballpark
11787630        11983807        101418042       101419997       196177	<- region 8 ballpark
16568563        16851015        1801309 2074398 282452
17715004        17992497        1277468 1290324 277493
18005358        18113794        84762251        84770807        108436
18122345        20392411        1303127 1307563 2270066			<- region 11 ballpark
22258174        22460340        2657475 2661085 202166			<- region 10 ballpark # Recmap shows no problem -- don't fix
79966496        79247633        8390796 8393172 -718863
79245245        79966634        60175490        60255169        721389

# I already have refined coordinates for region 11. 
# Let's lay out the strategy for piecing back together the chromosome
# 1: v14 6:1-1289739 +
# 2: topol 6:18017772-20387960 +	region 11
# 3: v14 6:1303128-101418191 +
# 4: topol 6:11787630-11983807 +	region 8
# 5: v14 6:110667049-111308022 +	First reshuffle
# 6: topol 6:11454547-11596051 +	region 7
# 7: v14 6:111308022-111564390 + 	second reshuffle
# 8: topol 6:6163121-6337744 +		region 4
# 9: v14 6:111564500-113452764 + 	third reshuffle
# 10: topol 6:8211909-8476467 +		region 5
# 11: v14 6:101418000-110661272 +

# Now to slice them all out and mix them all together
mkdir chr6fix
cd chr6fix/

samtools faidx ../../../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6:1-1289739 > chr6_seg1.fa
samtools faidx ../../../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6:1303128-101418191 > chr6_seg3.fa
samtools faidx ../../../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6:110667049-111308022 > chr6_seg5.fa
samtools faidx ../../../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6:111308022-111564390 > chr6_seg7.fa
samtools faidx ../../../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6:111564500-113452764 > chr6_seg9.fa
samtools faidx ../../../ARS-UCD1.0.14.clean.wIGCHaps.fasta 6:101418000-110661272 > chr6_seg11.fa

samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:18017772-20387960 > chr6_segs2.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:11787630-11983807 > chr6_segs4.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:11454547-11596051 > chr6_segs6.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:6163121-6337744 > chr6_segs8.fa
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta 6:8211909-8476467 > chr6_segs10.fa

for i in `seq 1 11`; do echo -e "chr6_seg"$i".fa\t+"; done > chr6_order.list
java -Xmx65g -jar /mnt/nfs/nfs2/bickhart-users/binaries/CombineFasta/store/CombineFasta.jar order -i chr6_order.list -o preliminary_v15_chr6.fa -p 100 -n "6"

# The fasta index shows 3 megs of additional sequence. Now to test
sbatch --nodes=1 --mem=10000 --ntasks-per-node=1 --wrap="bwa index preliminary_v15_chr6.fa"
sbatch /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a preliminary_v15_chr6.fa -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest.fa -o preliminary_v15_chr6.recmap
```
<a name="lastgasp"></a>
## One last gasp: an automated way of correcting misassemblies

I think that this will be my last efforts at correcting the problems in this assembly. I have a plan for an automated means of combining several sources of information to correct the current problems in the assembly:

1. HD probe presence and order
2. nucmer alignments
3. LD maps

Instead of laboring over manual ordering and orientation of chromosome fragments, I will let a program do all of the organization for me. First, I want to test out Jellyfish for repetitive kmer identification (I figure that repeats will be good sites for selecting breakpoints between markers).

> Assembler 2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_114_igc

```bash
module load jellyfish/2.2.3
sbatch --partition=assemble1 --nodes=1 --mem=200000 --ntasks-per-node=10 --wrap="jellyfish count -m 21 -s 2800M -t 10 -o ARS-UCD1.0.14.clean.wIGCHaps.jf ARS-UCD1.0.14.clean.wIGCHaps.fasta"
jellyfish histo -o ARS-UCD1.0.14.clean.wIGCHaps.jf.histo -t 10 ARS-UCD1.0.14.clean.wIGCHaps.jf

cat ARS-UCD1.0.14.clean.wIGCHaps.jf.histo | cut -d' ' -f2 | perl ~/sperl/bed_cnv_fig_table_pipeline/statStd.pl
total   8552
Minimum 1
Maximum 1965479361
Average 238297.096118
Median  4
Standard Deviation      21258817.588929
Mode(Highest Distributed Value) 1
```

The majority of sites were unique, making a kmer presence of 2 being highly unusual.

I'm now going to tag the HD probe fasta with UMD3.1 locations in order to allow my mapping program to estimate site locations and fragments.

> pwd: 

```bash
# Markers without chromosome mappings are useless for my analysis -- getting rid of them
perl -e 'for($x = 0; $x < 8; $x++){<>;} %data; while(<>){chomp; if($_ =~ /\[Controls\]/){last;} @s = split(/,/); if($s[9] == 0){next;} $data{$s[9]}->{$s[10]}->{$s[1]} = $s[5];} foreach my $chr (sort{$a cmp $b} keys(%data)){foreach my $pos (sort{$a <=> $b} keys(%{$data{$chr}})){foreach my $name (keys(%{data{$chr}->{$pos}})){ $seq = $data{$chr}->{$pos}->{$name}; print ">$name.$chr.$pos\n$seq\n";}}}' < BovineHD_B1.csv > BovineHD_B1.probseq.umdcoords.fa

# Let's now compare positions against the other probe fasta
perl -e 'chomp(@ARGV); open(IN, "< $ARGV[0]"); %markers; while($h = <IN>){<IN>; chomp $h; $h =~ s/\>//; @hsegs = split(/\./, $h); $markers{$hsegs[0]} = [$hsegs[1], $hsegs[2]];} close IN; open(IN, "< $ARGV[1]"); while($h = <IN>){<IN>; chomp $h; $h =~ s/\>//; @hsegs = split(/\./, $h); if(exists($markers{$hsegs[0]})){push(@{$markers{$hsegs[0]}}, ($hsegs[1], $hsegs[2]));}} close IN; foreach my $m (keys(%markers)){if($markers{$m}->[1] != $markers{$m}->[3]){print "$m\t"; print join("\t", @{$markers{$m}}); print "\n";}}' rcmap_manifest_correct.sorted.fa BovineHD_B1.probseq.umdcoords.fa | wc -l
2747	<- this is pretty much what the recmap coords predict as well

# Columns 1 and 2 are the recmap adjusted coords. 3 and 4 are the original UMD3 coords; sorted by UMD3 coords
perl -e 'chomp(@ARGV); open(IN, "< $ARGV[0]"); %markers; while($h = <IN>){<IN>; chomp $h; $h =~ s/\>//; @hsegs = split(/\./, $h); $markers{$hsegs[0]} = [$hsegs[1], $hsegs[2]];} close IN; open(IN, "< $ARGV[1]"); while($h = <IN>){<IN>; chomp $h; $h =~ s/\>//; @hsegs = split(/\./, $h); if(exists($markers{$hsegs[0]})){push(@{$markers{$hsegs[0]}}, ($hsegs[1], $hsegs[2]));}} close IN; foreach my $m (sort{$markers{$a}->[2] cmp $markers{$b}->[2] || $markers{$a}->[3] <=> $markers{$b}->[3]}keys(%markers)){if($markers{$m}->[1] != $markers{$m}->[3]){print "$m\t"; print join("\t", @{$markers{$m}}); print "\n";}}' rcmap_manifest_correct.sorted.fa BovineHD_B1.probseq.umdcoords.fa > bovine_hd_marker_remaps.tab

# Let's see if we can fix the intervening marker locations
# From a review of the ordered marker map, I think that I can be judicious with my corrections
# We don't need full fidelity, especially when allot of singleton markers cause issues, let's remove the singletons (no consecutive chromosome order) first

# Hold it, let's remap the coordinates to the UMD3 assembly to generate segments, and then make corrections from there
perl alignAndOrderSnpProbes.pl -a /mnt/nfs/nfs2/Genomes/umd3_kary_unmask_ngap.fa -p rcmap_manifest_correct.sorted.fa -o umd3_recmap_corrections

# Here are the problem regions:
#umd	umds	umde		rec	recs	rece
1	44569519	45113935	1	158140120	158140250
10	87334818	87763271	7	112319175	112359270
26	23129850	25982294	26	50280020	50800400
21	59908966	60851192	27	1	35000
6	106517123	109800287	6	126517122	129800337

# This script revises the coords above and evenly spaces probes between them
# Approximately 2000 probes are revised in this subset
perl reorder_problem_markers.pl BovineHD_B1.probseq.umdcoords.fa umd3_problem_regions.tab > BovineHD_B1.probseq.rev1coords.fa
```

Now that I have revised HD probe positions and a means of ordering things, let's try to grep out all missing sections of the v14 assembly that are in the ToPolish assembly. Then we'll add those sections to the v14 assembly and then hash it out from there.

<a name="fifteen"></a>
#### ARS-UCDv1.0.15

> Assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/assembly_revision

```bash
bwa mem ../ars_ucd_114_igc/ARS-UCD1.0.14.clean.wIGCHaps.fasta /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa > ARS-UCD1.0.14.clean.wIGCHaps.fasta.raw.probe.sam
bwa mem /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa > topolish.filledWithCPBJ.withX.no1b.fixed.nosplit.raw.probe.sam

perl -lane 'if($F[2] eq "*"){print $F[0];}' < ARS-UCD1.0.14.clean.wIGCHaps.fasta.raw.probe.sam > ARS-UCD1.0.14.clean.wIGCHaps.unmapped
perl -lane 'if($F[2] eq "*"){print $F[0];}' < topolish.filledWithCPBJ.withX.no1b.fixed.nosplit.raw.probe.sam > topolish.filledWithCPBJ.withX.no1b.fixed.nosplit.unmapped

# Hmm, none of Bob's coordinates are matching with my version of toPolish. I'm going to have to grep out the segments that contain the HD probes myself.
perl ~/sperl/bed_cnv_fig_table_pipeline/nameListVennCount.pl -l 1 ARS-UCD1.0.14.clean.wIGCHaps.unmapped topolish.filledWithCPBJ.withX.no1b.fixed.nosplit.unmapped | perl -lane 'if($F[0] =~ /^File/){next;}else{print $F[0];}' | perl -e '@coords; while(<>){chomp; open(IN, "grep $_ topolish.filledWithCPBJ.withX.no1b.raw.probe.sam |"); $l = <IN>; close IN; chomp $l; @segs = split(/\t/, $l); push(@coords, [$segs[2], $segs[3]]);} @coords = sort{$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]} @coords; @refined; push(@refined, [$coords[0]->[0], $coords[0]->[1], $coords[0]->[1]]); for($x = 1; $x < scalar(@coords); $x++){if($refined[-1]->[0] == $coords[$x]->[0] && $refined[-1]->[2] + 50000 > $coords[$x]->[1] && $refined[-1]->[2] - 50000 < $coords[$x]->[1]){$refined[-1]->[2] = $coords[$x]->[1];}else{push(@refined, [$coords[$x]->[0], $coords[$x]->[1], $coords[$x]->[1]]);}} foreach my $c (@refined){print join("\t", @{$c}); print "\n";}' > portions_topolish_fixed_missing.tab

perl -lane 'open(IN, "samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fixed.nosplit.fa $F[0]:$F[1]-$F[2] |"); while(<IN>){chomp; if($_ =~ /^>/){$_ =~ s/[:-]/_/g; print $_;}else{print $_;}} close IN;' < portions_topolish_fixed_missing.tab > chopped_from_v14.fa

# Now to make up the base fasta for the comparisons
cat ../ars_ucd_114_igc/ARS-UCD1.0.14.clean.wIGCHaps.fasta chopped_from_v14.fa > ARS-UCD1.0.14.base.plus.missing.fasta
samtools faidx ARS-UCD1.0.14.base.plus.missing.fasta
bwa index ARS-UCD1.0.14.base.plus.missing.fasta

# And to generate the files that I need to process the data
bwa mem ARS-UCD1.0.14.base.plus.missing.fasta /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa > ARS-UCD1.0.14.base.plus.missing.probes.sam
sbatch --partition=assemble1 --nodes=1 --mem=200000 --ntasks-per-node=10 --wrap="jellyfish count -m 21 -s 2800M -t 10 -o ARS-UCD1.0.14.base.plus.missing.jf ARS-UCD1.0.14.base.plus.missing.fasta"

java -jar CombineFasta.jar missassembly -s ARS-UCD1.0.14.base.plus.missing.probes.sam -f ARS-UCD1.0.14.base.plus.missing.fasta -j ARS-UCD1.0.14.base.plus.missing.jf -o ARS-UCD1.0.15.second 2> misassembly.run.log

# The AGP file is OK, but it modifies the source far too much. I'm going to tweak it manually with what I know about the original coordinates.
tail -n 35 ARS-UCD1.0.14.base.plus.missing.fasta.fai

perl -lane 'if($F[0] ne $F[5] && $F[4] eq "D" && $F[5] =~ /.+_.+_.+/){print $_;}' < ARS-UCD1.0.15.second.agp | grep -v 'Leftover' | grep -v 'Domino_MHCclassI' | grep -v 'MHC' | grep -v 'LRC'
# What follows are the condensed regions that were placed on the assembly using the HD marker order
23      495089  501494  4       D       23_30714833_30721217    -20     6385    +
26      387285  477148  2       D       26_333276_423139        -20     89843   +
26      1280604 1312936 7       D       26_1189806_1206429      -20     16624   +
26      11209159        11337614        26      D       26_11615113_11678432    1       63320    +
26      33655271        33738216        111     D       26_36455221_36506035    -20     50794   +
10      93957245        94035744        277     D       10_93572727_93604863    1       105051   +
13      360285  374386  4       D       21_69920012_70058600    21     14081   +
16      8941922 9257509 49      D       16_8021570_8201024      21     179455   +
16      9610054 9691210 67      D       16_8505081_8563918      1       58838   +
16      41219182        41227629        149     D       16_40025922_40034390    1       8448    +
2       104849811       104864034       254     D       2_121679633_121693877   1       14224   +
2       122421552       122433261       305     D       2_121828150_121839859   1       11710   +
6       84527044        84876564        166     D       6_22271154_22457408     162824  112824  -
6       86192110        86353468        203     D       6_20891768_20973292     1   81525   -
6       86888429        91624964        213     D       6_18017525_20384180     1 2366656 -
6       91764739        92079806        539     D       6_17722781_17881242     21  158462  -
6       93043741        93426429        561     D       6_16569212_16763827     1  194616  -
6       98027331        98407190        590     D       6_11787676_11983323     21  195648  -
6       98623678        98878020        632     D       6_11457367_11595092     1  137726  -
6       101828937       101877643       656     D       6_8486203_8522578       1   36376   -
6       102968147       103207483       662     D       6_7292925_7417583       1  124638  -
6       104187158       104511023       676     D       6_6165152_6329726       1  164575  -
6       105177508       105495125       712     D       6_5348934_5511199       1  162266  -
6       110169028       110353610       755     D       6_583968_679106 1   95139   -
7       93984   390391  3       D       7_109635008_109765175   1   130168  -
7       118104917       118217728       465     D       10_94144435_94249485    1   81202   -
21      1163767 1224131 4       D       21_69920012_70058600    14100   74464   +
21      1276588 1340715 6       D       21_69920012_70058600    74462   138589  +
21      27681701        27692844        108     D       21_43605183_43790615    1  185412  -
21      71076737        71146806        256     D       20_71893120_71931825    21   38706   -

# I manually editted the agp file to remove extraneous deviations. There were lots! 
# The file was originally 19,000 lines and is now closer to 2000

# Combining the AGP into a fasta file
java -jar CombineFasta.jar agp2fasta -f ARS-UCD1.0.14.base.plus.missing.fasta -a ARS-UCD1.0.15.second.agp -o ARS-UCD1.0.15.base.fasta

# Testing the number of unmapped probes:
bwa index ARS-UCD1.0.15.base.fasta
bwa mem ARS-UCD1.0.15.base.fasta /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa > ARS-UCD1.0.15.base.hdprobes.sam

# Also checking against the other datasets
perl -lane 'if($F[0] =~ /^@/){next;}elsif($F[2] =~ /\*/){print $F[0];}' < ARS-UCD1.0.15.base.hdprobes.sam > ARS-UCD1.0.15.base.hdprobes.unmapped

# I only mapped 67 probes! There's something wrong with the regions I added...
# Checking quickly to see if it's a problem with my agp2fasta script or something else
samtools faidx ARS-UCD1.0.15.base.fasta 6 > arsv15_chr6.fa
samtools faidx ARS-UCD1.0.14.base.plus.missing.fasta 6 > arsv14_chr6.fa
sbatch /mnt/nfs/nfs2/bickhart-users/binaries/run_nucmer_plot_automation_script.sh arsv15_chr6.fa arsv14_chr6.fa
```

<a name="sixteen"></a>
## Correcting mistaken areas for v16

OK, this is just to fix an error in the incorporation of the missing sections onto v15. Let's start from scratch and validate all of the missing regions.

```bash
# First, pull all markers that were missing
perl ~/sperl/bed_cnv_fig_table_pipeline/nameListVennCount.pl -o ARS-UCD1.0.14.clean.wIGCHaps.unmapped topolish.filledWithCPBJ.withX.no1b.fixed.nosplit.unmapped ARS-UCD1.0.15.base.hdprobes.unmapped
cat group_1.txt group_1_3.txt > arsv14_missing_probes_recoverable.list

# Now, condense the coordinates with a custom script
perl extract_missing_regions_from_sam.pl arsv14_missing_probes_recoverable.list topolish.filledWithCPBJ.withX.no1b.fixed.nosplit.raw.probe.sam > topolish.filledWithCPBJ.withX.no1b.fixed.nosplit.unmapped.bed

cat topolish.filledWithCPBJ.withX.no1b.fixed.nosplit.unmapped.bed | perl ~/sperl/bed_cnv_fig_table_pipeline/sortBedFileSTDIN.pl | mergeBed -i stdin -d 20000 -c 4,5 -o sum,collapse > topolish.filledWithCPBJ.wX.no1b.f.nos.un.condensed.bed

# OK, I found out the reason: Bob used the original ToPolish, no the "fixed' version.
dos2unix bobs_chunk_coordinates_original_topolish.bed
perl -lane 'open(IN, "samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/topolish.no1b/topolish.filledWithCanuAndPBJelly.withX.no1b.fasta $F[0]:$F[1]-$F[2] |"); while(<IN>){chomp; if($_ =~ /^>/){print ">$F[3]";}else{print $_;}} close IN;' < bobs_chunk_coordinates_original_topolish.bed > v15_missing_chunks.fa

# I am going to confirm that the probes map this time though
bwa index v15_missing_chunks.fa; bwa index ARS-UCD1.0.14.base.plus.v15missing.fasta
perl -e 'chomp(@ARGV); %h; open(IN, "< $ARGV[0]"); while(<IN>){chomp; $h{$_} = 1;} close IN; open(IN, "< $ARGV[1]"); while($h =<IN>){$s = <IN>; $h =~ /\>(.+)\n/; if(exists($h{$1})){print "$h$s";}} close IN;' arsv14_missing_probes_recoverable.list /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa > arsv14_missing_probes_recoverable.fa

perl /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a v15_missing_chunks.fa -p arsv14_missing_probes_recoverable.fa -o arsv14_missing_probes_recoverable.hd
perl ~/sperl/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f arsv14_missing_probes_recoverable.hd.tab -c 1
Entry   Count
*       161
chunk_1 11
chunk_10        39
chunk_11        640
chunk_12        13
chunk_13        10
chunk_14        27
chunk_15        4
chunk_16        3
chunk_17        26
chunk_18        13
chunk_2 35
chunk_20        27
chunk_21        5
chunk_22        32
chunk_23        9
chunk_24        5
chunk_26        11
chunk_27        8
chunk_28        18
chunk_29        28
chunk_3 57
chunk_4 34
chunk_5 30
chunk_6 7
chunk_7 54
chunk_8 109
chunk_9 55

# OK, now to generate the HD probe sam file
samtools faidx ARS-UCD1.0.14.base.plus.v15missing.fasta
sbatch --partition=assemble1 --nodes=1 --mem=200000 --ntasks-per-node=30 --wrap="jellyfish count -m 21 -s 2800M -t 30 -o ARS-UCD1.0.14.base.plus.v15missing.jf ARS-UCD1.0.14.base.plus.v15missing.fasta"

bwa mem ARS-UCD1.0.14.base.plus.v15missing.fasta /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa > ARS-UCD1.0.14.base.plus.v15missing.probes.sam

# now to go to town on the agp!
java -jar CombineFasta.jar missassembly -s ARS-UCD1.0.14.base.plus.v15missing.probes.sam -f ARS-UCD1.0.14.base.plus.v15missing.fasta -j ARS-UCD1.0.14.base.plus.v15missing.jf -o ARS-UCD1.0.16.base

# OK, here is the section of the agp file:
perl -lane '%h = ("2" => 1, "6" => 1, "10" => 1, "16" => 1, "21" => 1, "26" => 1); if(exists($h{$F[0]})){print $_;}' < ARS-UCD1.0.16.base.agp > ARS-UCD1.0.16.base.modifiedchrs.agp
perl -lane '%h = ("17" => 1, "9" => 1, "11" => 1, "27" => 1); if(exists($h{$F[0]})){print $_;}' < ARS-UCD1.0.16.base.agp > ARS-UCD1.0.16.base.modiiedchrs.addendum.agp

# I edited the above two files substantially
perl -lane '%h = ("2" => 1, "6" => 1, "10" => 1, "16" => 1, "21" => 1, "26" => 1, "17" => 1, "9" => 1, "11" => 1, "27" => 1); unless(exists($h{$F[0]}) || $F[0] =~ /chunk/){print "$F[0]\t1\t$F[1]\t1\tD\t$F[0]\t1\t$F[1]\t+";}' < ARS-UCD1.0.14.base.plus.v15missing.fasta.fai > ARS-UCD1.0.16.base.unmodifiedchrs.agp

wc -l *.agp
   9252 ARS-UCD1.0.15.edit.agp
   2335 ARS-UCD1.0.15.second.agp
  16872 ARS-UCD1.0.15.test.agp
  17988 ARS-UCD1.0.16.base.agp
    168 ARS-UCD1.0.16.base.modifiedchrs.agp
     40 ARS-UCD1.0.16.base.modiiedchrs.addendum.agp
   2200 ARS-UCD1.0.16.base.unmodifiedchrs.agp

cat ARS-UCD1.0.16.base.modifiedchrs.agp ARS-UCD1.0.16.base.modiiedchrs.addendum.agp ARS-UCD1.0.16.base.unmodifiedchrs.agp > ARS-UCD1.0.16.base.full.modified.agp

# Now to generate the fasta file
java -jar CombineFasta.jar agp2fasta -f ARS-UCD1.0.14.base.plus.v15missing.fasta -a ARS-UCD1.0.16.base.full.modified.agp -o ARS-UCD1.0.16.base.fasta

perl /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a ARS-UCD1.0.16.base.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa -o ARS-UCD1.0.16.HD.probes
perl /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a ARS-UCD1.0.16.base.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest_correct.sorted.fa -o ARS-UCD1.0.16.recmap

perl -e 'print "chr\tpos\trhchr\trhpos\n"; while(<>){chomp; @s = split(/\t/); print "$s[1]\t$s[2]\t$s[4]\t$s[5]\n";}' < ARS-UCD1.0.16.recmap.tab > ARS-UCD1.0.16.recmap.rtab

# Now to print it out in R
```

```R
source("/mnt/nfs/nfs2/bickhart-users/binaries/mick_watson_rhmap.R")

data <- read.delim("ARS-UCD1.0.16.recmap.rtab")
```

<a name="unmapped"></a>
#### Unmapped probe check

This is just a quick test to see how the unmapped probes line up between assemblies.

> Assembler2: 

```bash
bwa mem /mnt/nfs/nfs2/Genomes/umd3_kary_unmask_ngap.fa /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa | perl -lane 'if($F[0] =~ /^@/){next;}elsif($F[2] eq "*"){print $F[0];}' > umd3_unmapped_probes.list

bwa mem ARS-UCD1.0.16.base.fasta /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa | perl -lane 'if($F[0] =~ /^@/){next;}elsif($F[2] eq "*"){print $F[0];}' > arsv16_unmapped_probes.list

cat ARS-UCD1.0.14.clean.wIGCHaps.fasta.raw.probe.sam | perl -lane 'if($F[0] =~ /^@/){next;}elsif($F[2] eq "*"){print $F[0];}' > arsv14_unmapped_probes.list
cat topolish.filledWithCPBJ.withX.no1b.raw.probe.sam | perl -lane 'if($F[0] =~ /^@/){next;}elsif($F[2] eq "*"){print $F[0];}' > topolish_unmapped_probes.list

perl ~/sperl/bed_cnv_fig_table_pipeline/nameListVennCount.pl umd3_unmapped_probes.list topolish_unmapped_probes.list arsv14_unmapped_probes.list arsv16_unmapped_probes.list

File Number 1: umd3_unmapped_probes.list
File Number 2: topolish_unmapped_probes.list
File Number 3: arsv14_unmapped_probes.list
File Number 4: arsv16_unmapped_probes.list
Set     Count
1       18
1;2     1
1;2;3;4 16
2       86
2;3;4   957
2;4     1
3       1466
3;4     204
4       105

# Now to generate a plot in R

# Additional comparisons
bwa mem /mnt/nfs/nfs2/dbickhart/dominette_asm/canu.mhap.all.fasta /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa | perl -lane 'if($F[0] =~ /^@/){next;}elsif($F[2] eq "*"){print $F[0];}' > canu_mhap_unmapped_probes.list
bwa mem /mnt/nfs/nfs2/dbickhart/dominette_asm/canu.minimap.fasta /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa | perl -lane 'if($F[0] =~ /^@/){next;}elsif($F[2] eq "*"){print $F[0];}' > canu_minimap_unmapped_probes.list


```

The Venn diagram plots for the initial four assemblies:

```R
library(VennDiagram)
# This is just of the initial four assemblies
venn.plot <- draw.quad.venn(area1 = 35, area2 = 1061, area3 = 2643, area4 = 1283, n12 = 17, n13 = 16, n14 = 16, n23 = 973, n24 = 974, n34 = 1177, n123 = 16, n134 = 16, n124 = 16, n234 = 957, n1234 = 16, category = c("umd3", "topolish", "v14", "v16"), fill = c("orange", "red", "green", "blue"), cex = 2, cat.cex = 2, cat.col = c("orange", "red", "green", "blue")) 
dev.copy2pdf(file="unmapped_hdprobes.pdf", useDingbats=FALSE)
```

Checking Bob's LD plots to see if I can generate a relative order for the markers.

```bash
# Creating a graphviz plot template
perl -e '<>; print "graph A \{\n"; while(<>){chomp; @s = split(/,/); print "\t$s[0] -> $s[1];\n";} print "\}\n";' < 171005_HD_LD_0.9_0.5.csv > 171005_HD_LD_0.9_0.5.graph

# It didn't work very well -- the graph hung in a cyclic processing mode
```

<a name="seventeen"></a>
## Generating v17 from modified AGP

Ben ran some mapping analysis from the Canu assembly to try to place contigs and has some insertion points. I will take his modified AGP file and run it through my pipeline. The new placed "chunk" that I was unable to place before is chunk_14, and there are several canu.mhap.all.fasta tigs that he placed. Here are the tigs that need to be placed:

* tig00000805
* tig00002319
* tig00009352
* tig00009354
* tig00001238
* tig00009563
* tig00009450
* tig00009711
* tig00009397
* tig00009521

> Assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/assembly_revision

```bash
# Getting the unique list of tigs from the agp that need to be in the base fasta
grep 'tig0' ARS-UCD1.0.17.base.16and26fixed_BDR.agp | perl -lane 'print $F[5];' | sort | uniq
tig00000805
tig00001238
tig00002319
tig00009352
tig00009354
tig00009397
tig00009450
tig00009521
tig00009563
tig00009711

for i in `grep 'tig0' ARS-UCD1.0.17.base.16and26fixed_BDR.agp | perl -lane 'print $F[5];' | sort | uniq `; do echo $i; samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/canu.mhap.all.fasta $i >> missing_in_16.fa; done
# Check to see the info is there
samtools faidx missing_in_16.fa

# Generating v14 base + missing topolish chunks + missing canu.mhap chunks
cat ARS-UCD1.0.14.base.plus.v15missing.fasta missing_in_16.fa > ARS-UCD1.0.15.base.plus.v15v16missing.fasta
samtools faidx ARS-UCD1.0.15.base.plus.v15v16missing.fasta
# BWA indexing using increased blocksize (-b = (genomesize) / 8) to improve speed
bwa index -b 350000000 ARS-UCD1.0.15.base.plus.v15v16missing.fasta

# That actually made it take 1.5 times longer!
# Generating the fasta file
java -jar CombineFasta.jar agp2fasta -f ARS-UCD1.0.15.base.plus.v15v16missing.fasta -a ARS-UCD1.0.17.base.16and26fixed_BDR.agp -o ARS-UCD1.0.17.base.fasta

sbatch --nodes=1 --ntasks-per-node=1 --mem=15000 --wrap="bwa index ARS-UCD1.0.17.base.fasta; perl /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a ARS-UCD1.0.17.base.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa -o ARS-UCD1.0.17.base.HDprobes"

```

Testing coverage around breakpoints of one region of the assembly to ensure proper tig placement.

> Assembler2: /mnt/nfs/nfs2/bickhart-users/natdb_sequencing

```bash
perl -ane '@bsegs = split(/\//, $F[0]); @nsegs = split(/\./, $bsegs[-1]); open(IN, "samtools view $F[0] 7:67845000-67848000 |"); my %c; while(<IN>){chomp; @s = split(/\t/); if($s[4] == 0){next;} $bin = int((($s[3] - 67845000) / 200) + 0.5); if($bin < 0){$bin = 0;} $c{$bin} += 1;} close IN; print "$nsegs[0]"; for($x = 0; $x < 16; $x++){if(exists($c{$x})){print "\t$c{$x}";}else{print "\t0";}} print "\n";' < igc_variant_list_bams.list
```

<a name="eighteen"></a>
#### Generating version 18

```bash
# v17 assembly creation
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/canu.mhap.all.fasta tig00000206 > missing_in_17.fa
cat ARS-UCD1.0.15.base.plus.v15v16missing.fasta missing_in_17.fa > ARS-UCD1.0.14.base.plus.v15v16v17missing.fasta

sbatch --nodes=1 --ntasks-per-node=1 --mem=25000 --wrap="bwa index ARS-UCD1.0.14.base.plus.v15v16v17missing.fasta; java -jar CombineFasta.jar agp2fasta -f ARS-UCD1.0.14.base.plus.v15v16v17missing.fasta -a ARS-UCD1.0.18.base.agp -o ARS-UCD1.0.18.base.fasta; samtools faidx ARS-UCD1.0.18.base.fasta; bwa index ARS-UCD1.0.18.base.fasta; perl /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a ARS-UCD1.0.18.base.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa -o ARS-UCD1.0.18.HDprobes"
```

#### Checking Jellyfish kmers for marker ID

> assembler2: /mnt/nfs/nfs1/derek.bickhart/ARS-UCD_kmer

```bash
module load jellyfish/2.2.3
sbatch --partition=assemble1 --nodes=1 --mem=300000 --ntasks-per-node=30 --wrap='gunzip -c /mnt/nfs/nfs2/brosen/projects/ARS-UCD/new_Dominette_NextSeq_data/*/*.gz | jellyfish count -m 21 -s 3G --bf-size 100G -t 30 -C -o dominette_nextseq_21mer.jf'

# Damn, that didn't work. Trying the generators approach
ls /mnt/nfs/nfs2/brosen/projects/ARS-UCD/new_Dominette_NextSeq_data/*/*.gz | xargs -n 1 echo gunzip -c > generators
sbatch --partition=assemble1 --nodes=1 --mem=300000 --ntasks-per-node=30 --wrap='jellyfish count -g generators -m 21 -s 3G --bf-size 100G -t 30 -C -o dominette_nextseq_21mer.jf'

jellyfish histo -o dominette_nextseq_21mer.histo dominette_nextseq_21mer.jf
jellyfish dump -o dominette_nextseq_21mer.count -c dominette_nextseq_21mer.jf

python check_probeseq_kmers.py 21 dominette_nextseq_21mer.jf /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa > kmer_check_stdout.tab
```

<a name="nineteen"></a>
#### Generating version 19

> Assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_119

```bash
# v18 base assembly creation
perl -lane 'if($F[0] =~ /^\d{1,2}/ || $F[0] eq "X"){next;}else{print $_;}' < ../assembly_revision/ARS-UCD1.0.18.base.agp > unplaced_scaffolds.agp
perl -lane 'print join("\t", @F);' < ARS-UCD1.0.19.temp.agp > placed_scaffolds.agp

grep 'tig' placed_scaffolds.agp | perl -lane 'print $F[5];' | sort | uniq | xargs -I {} echo -n "{} "; echo
samtools faidx /mnt/nfs/nfs2/dbickhart/dominette_asm/canu.mhap.all.fasta tig00000085 tig00000329 tig00000500 tig00000647 tig00000858 tig00000965 tig00001202 tig00001238 tig00001442 tig00001536 tig00001537 tig00001622 tig00001843 tig00002144 tig00002319 tig00002327 tig00002575 tig00002621 tig00002631 tig00002815 tig00009264 tig00009272 tig00009301 tig00009354 tig00009366 tig00009414 tig00009416 tig00009422 tig00009438 tig00009474 tig00009487 tig00009498 tig00009535 tig00009552 tig00009778 > missing_in_18.fa

cat ARS-UCD1.0.18.base.fasta missing_in_18.fa > ARS-UCD1.0.18.plusmissing.fasta
samtools faidx ARS-UCD1.0.18.plusmissing.fasta
cat placed_scaffolds.agp unplaced_scaffolds.agp > ARS-UCD1.0.19.base.agp

# Had an error with the agp format
perl -e 'while(<>){chomp; @s = split(/\t/); if(scalar(@s) < 9){print "$_\n";}}' < ARS-UCD1.0.19.base.agp
6       1       117468312       303     D       6       62227145        104378052 
# Was missing an orientation flag, so I added a "+"
```
<a name="twentytwo"></a>
## Polishing the arrowed assembly: ARS-UCDv1.22

I just need to run alignments of the Dominette data to polish the assembly now.

> Assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_v121

```bash
# Downloading the ASM
wget https://gembox.cbcb.umd.edu/seqdata/bos_taurus/asm/ARS-UCDv1.0.21.fasta

# Removing the stupid arrow tags
perl -ne 'if($_ =~ /^>/){$_ =~ s/\|arrow//; print $_;}else{print $_;}' < ARS-UCDv1.0.21.fasta > ARS-UCDv1.0.21.reformat.fasta

# Just checking to make sure that my one-liner didn't do any damage
samtools faidx ARS-UCDv1.0.21.reformat.fasta
# Looks good.

# Gathering all of the reads that I will use for polishing
ls /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_110/dominette_fastqs/*.fastq > sra_dominette_fastqs.list
ls /mnt/nfs/nfs2/brosen/projects/ARS-UCD/new_Dominette_NextSeq_data/*/*.fastq | grep -v 9.16.16 > tim_nextseq_dominette_fastqs.list

cat sra_dominette_fastqs.list tim_nextseq_dominette_fastqs.list > pilon_polishing_fastq_list.tab
# Manually editting using Vim

# OK, ready to go
bwa index ARS-UCDv1.0.21.reformat.fasta; perl ~/sperl/sequence_data_pipeline/generateAlignSlurmScripts.pl -b aligns -t pilon_polishing_fastq_list.tab -f ARS-UCDv1.0.21.reformat.fasta -p assemble1 -m

perl ~/sperl/assembly_scripts/slurmPilonFasta.pl -f aligns/dominette/dominette.sorted.merged.bam -g ARS-UCDv1.0.21.reformat.fasta -o pilon -p assemble3

# Oops! The minimum memory state was too low! I need to change some things
# Changing it to 9000 megs
for i in scripts/*ScbfJmS*.sh; do echo $i; perl -ne '$_ =~ s/--mem=1000/--mem=9000/; $_ =~ s/-Xmx1000M/-Xmx9000M/; print $_;' < $i > temp; mv temp $i; done

# Now, concatenating the pilon fastas into an ordered list
cd pilon
# It's super convoluted, but I resorted by chr length and then sorted the top 30 chromosomes (autosomes and X) numerically
perl -e 'chomp(@ARGV); open(IN, "< $ARGV[0]"); @chrs; while(<IN>){chomp; @s = split(/\t/); push(@chrs, [$s[0],$s[1]]);} close IN; @chrs = sort {$b->[1] <=> $a->[1]} @chrs; my @temp; for($x = 0; $x < 30; $x++){push(@temp, $chrs[$x]);} @temp = sort {$x = $a->[0]; $y = $b->[0]; if($x eq "X"){$x = 500;} if($y eq "X"){$y = 500;} $x <=> $y} @temp; for($x = 0; $x < 30; $x++){$chrs[$x] = $temp[$x];} open(OUT, "> ../ARS-UCD_v21_pilon_corrected.temp.fa"); %printed; foreach my $c (@chrs){$j = $c->[0]; my $f = "$j.pilon.fasta"; open(IN, "< $f") || die "Could not open file: $f!\n"; my $eline = <IN>; $eline =~ s/_pilon//; print {OUT} $eline; while(<IN>){print {OUT} $_;} close IN;}' ../ARS-UCDv1.0.21.reformat.fasta.fai
cd ../

# Now to check Scaffold orientation
sbatch --nodes=1 --mem=20000 --ntasks-per-node=1 --wrap="bwa index ARS-UCD_v21_pilon_corrected.temp.fa"
perl /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a ARS-UCD_v21_pilon_corrected.temp.fa -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/rcmap_manifest_correct.sorted.fa -o ARS-UCD_v21_pilon_corrected.recmap
# Autosomes that are reversed: 1, 8, 12, 15, 16, 17, 18, 20, 22, 25, 29

# I will have to check ChrX orientation separately
samtools faidx ARS-UCD_v21_pilon_corrected.temp.fa X > v21_corrected_X.fa
samtools faidx ../ars_ucd_119/ARS-UCD1.0.19.base.fasta X > v19_uncorrected_X.fa
sbatch /mnt/nfs/nfs2/bickhart-users/binaries/run_nucmer_plot_automation_script.sh v19_uncorrected_X.fa v21_corrected_X.fa

# The mcoords align up. Looks like the X chromosome is in the right orientation
perl ~/sperl/assembly_scripts/faiToAGP.pl ARS-UCD_v21_pilon_corrected.temp.fa.fai ARS-UCD_v22_reorient_fasta.agp
# I edited the orientation based on the prior analysis
java -jar ../ars_ucd_119/CombineFasta.jar agp2fasta -f ARS-UCD_v21_pilon_corrected.temp.fa -a ARS-UCD_v22_reorient_fasta.agp -o ARS-UCDv1.0.22.fasta
samtools faidx ARS-UCDv1.0.22.fasta

# Quick test to confirm scaffold lengths match up
perl -lane 'print "$F[0]\t$F[1]";' < ARS-UCDv1.0.21.reformat.fasta.fai | sort -k1 > ARS-UCDv1.0.21.reformat.fasta.fai.sorted
perl -lane 'print "$F[0]\t$F[1]";' < ARS-UCDv1.0.22.fasta.fai | sort -k1 > ARS-UCDv1.0.22.fasta.fai.sorted
perl -lane 'print "$F[0]\t$F[1]";' < ARS-UCD_v21_pilon_corrected.temp.fa.fai | sort -k1 > ARS-UCD_v21_pilon_corrected.temp.fa.fai.sorted

diff ARS-UCDv1.0.21.reformat.fasta.fai.sorted ARS-UCDv1.0.22.fasta.fai.sorted # just about everything, so Pilon correction made alterations
diff ARS-UCD_v21_pilon_corrected.temp.fa.fai.sorted ARS-UCDv1.0.22.fasta.fai.sorted # nothing, as expected

# Checking gap content after the polishing
java -jar /mnt/nfs/nfs2/bickhart-users/binaries/GetMaskBedFasta/store/GetMaskBedFasta.jar -f ARS-UCD_v21_pilon_corrected.temp.fa -o ARS-UCD_v21_pilon_corrected.temp.gaps.bed -s ARS-UCD_v21_pilon_corrected.temp.gaps.stats

java -jar /mnt/nfs/nfs2/bickhart-users/binaries/GetMaskBedFasta/store/GetMaskBedFasta.jar -f ARS-UCDv1.0.22.fasta -o ARS-UCDv1.0.22.gaps.bed -s ARS-UCDv1.0.22.gaps.stats
```

<a name="twentythree"></a>
## Gap resizing: ARS-UCDv1.23

Now I am going to try to isolate the gaps that are > 100 bp and standardize them to 250 bp each. I need to use my AGP program to do this, and it will be a bit of a pain to reconcile coordinates, but I will try!

Let's first isolate the gaps that need to be resized, then subtract them from a bed file of chromosome coordinates and proceed from there.

> Assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_121

```bash
perl -lane 'if($F[2] - $F[1] > 100){print $_;}' < ARS-UCDv1.0.22.gaps.bed | wc -l
823

# Hmm... that's alot more than I expected! 
# I found out why: my CombineFasta.jar program accidentally masked lowercase bases.
# Redoing...
java -jar CombineFasta.jar agp2fasta -f ARS-UCD_v21_pilon_corrected.temp.fa -a ARS-UCD_v22_reorient_fasta.agp -o ARS-UCDv1.0.22.fasta
java -jar /mnt/nfs/nfs2/bickhart-users/binaries/GetMaskBedFasta/store/GetMaskBedFasta.jar -f ARS-UCDv1.0.22.fasta -o ARS-UCDv1.0.22.gaps.bed -s ARS-UCDv1.0.22.gaps.stats

perl -lane 'if($F[2] - $F[1] > 100){print $_;}' < ARS-UCDv1.0.22.gaps.bed | wc -l
42

# Pssh, only 42? That's not too hard to reconcile
perl -lane 'if($F[2] - $F[1] > 100){print $_;}' < ARS-UCDv1.0.22.gaps.bed > ARS-UCDv1.0.22.gaps.gt100.bed
cat ARS-UCDv1.0.22.fasta.fai | sort -k2n | tail -n 30 | perl -lane 'print "$F[0]\t1\t$F[1]";' | bedtools sort -i stdin > ARS-UCDv1.0.22.fasta.chrs.bed

bedtools subtract -a ARS-UCDv1.0.22.fasta.chrs.bed -b ARS-UCDv1.0.22.gaps.gt100.bed | perl bedtools_to_agp.pl  > ars_ucd_v23_major_chrs.agp

# ChrX had a noticeably smaller profile
perl -lane 'if(length($F[0]) > 2){print $_;}' < ARS-UCD_v22_reorient_fasta.agp > ars_ucd_v23_unplaced_chrs.agp

# Now to combine them all and generate the final assembly fasta
cat ars_ucd_v23_major_chrs.agp ars_ucd_v23_unplaced_chrs.agp > ARS-UCD_v23_gapresize.agp
# I think I'm ready to generate v23
java -jar CombineFasta.jar agp2fasta -f ARS-UCDv1.0.22.fasta -a ARS-UCD_v23_gapresize.agp -o ARS-UCDv1.0.23.fasta
samtools faidx ARS-UCDv1.0.22.fasta

java -jar /mnt/nfs/nfs2/bickhart-users/binaries/GetMaskBedFasta/store/GetMaskBedFasta.jar -f ARS-UCDv1.0.23.fasta -o ARS-UCDv1.0.23.gaps.bed -s ARS-UCDv1.0.23.gaps.stats
```

<a name="finalparity"></a>
#### Final parity checks

Going to test out the HD probes to see if everything makes sense

> Assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_123

```bash
perl /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/alignAndOrderSnpProbes.pl -a ARS-UCDv1.0.23.fasta -p /mnt/nfs/nfs2/dbickhart/dominette_asm/recombination/BovineHD_B1.probseq.rev1coords.fa -o ARS-UCDv1.0.23.hdprobes

# only 853 unmapped probes
perl -lane 'if($F[1] eq "*"){print $F[0];}' < ARS-UCDv1.0.23.hdprobes.tab > ARS-UCDv1.0.23.hdprobes.unmapped.list

perl -lane 'if($F[1] eq "*"){print $F[4];}' < ARS-UCDv1.0.23.hdprobes.tab | perl ~/sperl/bed_cnv_fig_table_pipeline/tabFileColumnCounter.pl -f stdin -c 0 -m
```
#### Unmapped HD probes per chromosome

|Entry | Count|
|:-----|-----:|
|10    |    50|
|11    |    16|
|12    |    24|
|13    |    21|
|14    |    13|
|15    |    24|
|16    |    11|
|17    |   303|
|18    |    31|
|19    |    22|
|20    |    14|
|21    |    19|
|22    |    11|
|23    |    15|
|24    |     3|
|25    |     6|
|26    |    10|
|27    |     9|
|28    |     5|
|29    |    20|

That's not too bad! chr17 is a bit off, but that may be due to smaller segments of unmapped probes. In subsequent manual checks, most of the regions identified in chr17 were in gene deserts or were regions of increasing heterozygosity in Dominette.

<a name="dataanalysis"></a>
## Initial data analysis

I am going to start to generate some initial data for the forthcoming publication. First steps: Repeatmasking and classification. Then I will dig out my email from Jared Decker and see if his strategy for locating high depth gap regions using an association study works. 

#### Repeatmasking

> Assembler2: /mnt/nfs/nfs2/bickhart-users/cattle_asms/ars_ucd_123

```bash
# This should be relatively easy to set up
mkdir rmask
sbatch --nodes=1 --ntasks-per-node=30 --mem=25000 --partition=assemble1 --wrap="/mnt/nfs/nfs2/bickhart-users/binaries/RepeatMasker/RepeatMasker -pa 30 -species cow -no_is -dir rmask ARS-UCDv1.0.23.fasta"